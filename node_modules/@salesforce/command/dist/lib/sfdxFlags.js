"use strict";
/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const core_1 = require("@salesforce/core");
const lodash_1 = require("lodash");
const url_1 = require("url");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/command', 'flags');
const FLAGS = {
    // required by all commands
    json: {
        description: messages.getMessage('jsonFlagDescription'),
        longDescription: messages.getMessage('jsonFlagLongDescription'),
        required: false,
        type: 'boolean'
    },
    loglevel: {
        description: messages.getMessage('loglevelFlagDescription'),
        longDescription: messages.getMessage('loglevelFlagLongDescription'),
        required: false,
        options: core_1.Logger.LEVEL_NAMES,
        type: 'enum'
    },
    // supported by SOME commands
    // to include in --help, register flag in flagsConfig, eg { verbose: true }; include
    // description and longDescription to override default descriptions
    apiversion: {
        description: messages.getMessage('apiversionFlagDescription'),
        longDescription: messages.getMessage('apiversionFlagLongDescription'),
        parse: val => {
            if (core_1.sfdc.validateApiVersion(val)) {
                return val;
            }
            throw core_1.SfdxError.create('@salesforce/command', 'flags', 'InvalidApiVersionError', [val]);
        },
        required: false,
        type: 'string'
    },
    concise: {
        description: messages.getMessage('conciseFlagDescription'),
        longDescription: messages.getMessage('conciseFlagLongDescription'),
        required: false,
        type: 'boolean'
    },
    quiet: {
        description: messages.getMessage('quietFlagDescription'),
        longDescription: messages.getMessage('quietFlagLongDescription'),
        required: false,
        type: 'boolean'
    },
    targetusername: {
        char: 'u',
        description: messages.getMessage('targetusernameFlagDescription'),
        longDescription: messages.getMessage('targetusernameFlagLongDescription'),
        required: false,
        type: 'string'
    },
    targetdevhubusername: {
        char: 'v',
        description: messages.getMessage('targetdevhubusernameFlagDescription'),
        longDescription: messages.getMessage('targetdevhubusernameFlagLongDescription'),
        required: false,
        type: 'string'
    },
    verbose: {
        description: messages.getMessage('verboseFlagDescription'),
        longDescription: messages.getMessage('verboseFlagLongDescription'),
        required: false,
        type: 'boolean'
    }
};
function validateType(isValid, path, flagType, correct) {
    if (isValid) {
        return path;
    }
    throw core_1.SfdxError.create('@salesforce/command', 'flags', 'InvalidFlagTypeError', [path, flagType, correct || '']);
}
const FLAGTYPES = {
    array: {
        parse: val => validateType(val.split(','), val, 'array')
    },
    date: {
        parse: val => validateType(!!Date.parse(val), val, 'date', ` ${messages.getMessage('FormattingMessageDate')}`)
    },
    datetime: {
        parse: val => validateType(!!Date.parse(val), val, 'datetime', ` ${messages.getMessage('FormattingMessageDate')}`)
    },
    directory: {
        parse: val => validateType(core_1.sfdc.validatePathDoesNotContainInvalidChars(val), val, 'directory')
    },
    email: {
        parse: val => validateType(core_1.sfdc.validateEmail(val), val, 'email')
    },
    filepath: {
        parse: val => validateType(core_1.sfdc.validatePathDoesNotContainInvalidChars(val), val, 'filepath')
    },
    id: {
        parse: val => validateType(core_1.sfdc.validateSalesforceId(val), val, 'id', ` ${messages.getMessage('FormattingMessageId')}`)
    },
    number: {
        parse: val => validateType(lodash_1.isFinite(lodash_1.toNumber(val)), val, 'number')
    },
    time: {
        parse: val => {
            const dateVal = new Date(`2000-01-02 ${val}`);
            return validateType(!!Date.parse((dateVal.toDateString())), val, 'time');
        }
    },
    url: {
        parse: val => {
            let isValid;
            try {
                isValid = new url_1.URL(val);
            }
            catch (err) {
                isValid = false;
            }
            return validateType(!!isValid, val, 'url', ` ${messages.getMessage('FormattingMessageUrl')}`);
        }
    }
};
/**
 * Builds a custom flag; parses and validates Salesforce supported flag types. E.g., { type: 'filepath' }. These include:
 *      1. array: a comma-separated list of strings, E.g., "one,two,three"
 *      2. date, datetime: a valid date, E.g., "01-02-2000" or "01/02/2000 01:02:34"
 *      3. directory, filepath: see {SfdxUtil.validatePathDoesNotContainInvalidChars}, E.g. "this/is/my/path"
 *      4. email: see {SfdxUtil.validateEmail}, E.g., "me@my.org"
 *      5. id: see {SfdxUtil.validateSalesforceId}, E.g., "00Dxxxxxxxxxxxx"
 *      6. number: an integer or floating point number, E.g., "42"
 *      7. time: a valid time, E.g., "01:02:03"
 *      8. url: a valid url, E.g., "http://www.salesforce.com"
 * @param {Flags.Output} flg The flag configuration.
 * @returns {Flags.Input<any} The flag for the command.
 */
function buildCustomFlag(flg) {
    return FLAGTYPES[flg.type] ? command_1.flags.build(flg)(FLAGTYPES[flg.type]) : command_1.flags.build(flg)();
}
/**
 * Validate the custom flag configuration. This includes:
 *      1. The flag name is in all lowercase.
 *      2. A string description is provided.
 *      3. If a char attribute is provided, it is one alphabetical character in length
 *      4. If a long description is provided, it is a string
 * @param {Flags.Output} flg The flag configuration.
 * @param {string} key The flag name.
 * @throws SfdxError If the criteria is not meet.
 */
function validateCustomFlag(flg, key) {
    if (!/^(?!(?:[-]|[0-9]*$))[a-z0-9-]+$/.test(key)) {
        throw core_1.SfdxError.create('@salesforce/command', 'flags', 'InvalidFlagName', [key]);
    }
    if (!flg.description || !lodash_1.isString(flg.description)) {
        throw core_1.SfdxError.create('@salesforce/command', 'flags', 'MissingOrInvalidFlagDescription', [key]);
    }
    if (flg.char && (flg.char.length !== 1 || !/[a-zA-Z]/.test(flg.char))) {
        throw core_1.SfdxError.create('@salesforce/command', 'flags', 'InvalidFlagChar', [key]);
    }
    if (flg.longDescription !== undefined && !lodash_1.isString(flg.longDescription)) {
        throw core_1.SfdxError.create('@salesforce/command', 'flags', 'InvalidLongDescriptionFormat', [key]);
    }
}
/**
 *  Build a flag, taking either the name of an SFDX flag or a flag definition.
 *  Uses the type in the definition if there is a builder for it, otherwise
 *  it builds a custom flag.
 * @param {string | SfdxFlagsConfig} flg The name of an SFDX flag or a flag configuration.
 * @param {string} [key] The flag name.
 * @returns {Flags.Input<any} The flag for the command.
 */
function buildFlag(flg, key) {
    const f = lodash_1.isString(flg) ? FLAGS[flg] : flg;
    // Validate custom flags only; SFDX flags unnecessary
    if (key) {
        validateCustomFlag(f, key);
    }
    return (f.type && command_1.flags[f.type]) ? command_1.flags[f.type](f) : buildCustomFlag(f);
}
/**
 * Builds flags for a command given a configuration object.  Supports the following usecases:
 *     1. Enabling common SFDX flags. E.g., { verbose: true }
 *     2. Disabling common SFDX flags. E.g., { apiversion: false }
 *     3. Overriding common SFDX flags.  E.g., { targetusername: { required: true } }
 *     4. Defining typed flags.  E.g., { myFlag: { char: '-m', type: 'array' }}
 *     5. Defining oclif flags.  E.g., { myFlag: Flags.boolean({ char: '-f' }) }
 *     6. Defining custom flag types.  E.g., { myCustomFlag: { parse: (val) => parseInt(val, 10) }}
 *
 * @param {SfdxFlagsConfig} flagsConfig The configuration object for a flag.  @see {@link SfdxFlagsConfig}
 * @returns {Flags.Input<any} The flags for the command.
 */
function buildSfdxFlags(flagsConfig = {}) {
    // The default flag options for SFDX commands.
    const DEFAULT_SFDX_FLAGS = {
        json: buildFlag('json'),
        loglevel: buildFlag('loglevel')
    };
    return lodash_1.reduce(flagsConfig, (flgs, val, key) => {
        // All commands MUST support json and loglevel flags
        if (key === 'json' || key === 'loglevel') {
            return flgs;
        }
        else if (val === false) {
            // Turn off the flag
            delete flgs[key];
        }
        else if (val === true) {
            // Turn on the flag if it's a known SFDX flag
            if (FLAGS[key]) {
                flgs[key] = buildFlag(key);
            }
            else {
                throw core_1.SfdxError.create('@salesforce/command', 'flags', 'UnknownFlagError', [key]);
            }
        }
        else {
            // Add the command-defined flag config
            flgs[key] = buildFlag(FLAGS[key] ? Object.assign({}, FLAGS[key], val) : val, key);
        }
        return flgs;
    }, DEFAULT_SFDX_FLAGS);
}
exports.buildSfdxFlags = buildSfdxFlags;
//# sourceMappingURL=sfdxFlags.js.map