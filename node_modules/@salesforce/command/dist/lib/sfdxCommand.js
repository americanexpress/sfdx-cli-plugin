"use strict";
/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const chalk_1 = require("chalk");
const sfdxFlags_1 = require("./sfdxFlags");
const ux_1 = require("./ux");
core_1.Messages.importMessagesDirectory(__dirname);
/**
 * A class that handles command results and formatting.  Use this class
 * to override command display behavior or to get complex table formatting.
 * For simple table formatting, use {@link SfdxCommand.tableColumnData} to
 * define a string array of keys to use as table columns.
 */
class Result {
    constructor(config = {}) {
        this.tableColumnData = config.tableColumnData;
        if (config.display) {
            this.display = config.display.bind(this);
        }
    }
    display() {
        if (this.tableColumnData) {
            if (Array.isArray(this.data) && this.data.length) {
                this.ux.table(this.data, this.tableColumnData);
            }
            else {
                this.ux.log('No results found.');
            }
        }
    }
}
exports.Result = Result;
/**
 * A base command that provides convenient access to common SFDX flags, a logger,
 * CLI output formatting, scratch orgs, and devhubs.  Extend this command and set
 * various static properties and a flag configuration to add SFDX behavior.
 *
 * @extends @oclif/command
 * @see https://github.com/oclif/command
 */
class SfdxCommand extends command_1.Command {
    constructor() {
        super(...arguments);
        this.isJson = false;
    }
    // Overrides @oclif/command static flags property.  Adds username flags
    // if the command supports them.  Builds flags defined by the command's
    // flagsConfig static property.
    static get flags() {
        const enableTargetUsername = !!(this.supportsUsername || this.requiresUsername);
        const enableTargetDevhubUsername = !!(this.supportsDevhubUsername || this.requiresDevhubUsername);
        const baseFlags = {
            targetusername: enableTargetUsername,
            targetdevhubusername: enableTargetDevhubUsername,
            apiversion: enableTargetUsername || enableTargetDevhubUsername
        };
        return sfdxFlags_1.buildSfdxFlags(Object.assign(baseFlags, this.flagsConfig));
    }
    async _run() {
        const ctor = this.constructor;
        // If a result is defined for the command, use that.  Otherwise check for a
        // tableColumnData definition directly on the command.
        if (!ctor.result.tableColumnData && ctor.tableColumnData) {
            ctor.result.tableColumnData = ctor.tableColumnData;
        }
        this.result = new Result(ctor.result);
        let err;
        try {
            await this.init();
            return this.result.data = await this.run();
        }
        catch (e) {
            err = e;
            await this.catch(e);
        }
        finally {
            await this.finally(err);
        }
    }
    // Assign this.project if the command requires to be run from within a project.
    async assignProject() {
        // Throw an error if the command requires to be run from within an SFDX project but we
        // don't have a local config.
        try {
            this.project = await core_1.SfdxProject.resolve();
        }
        catch (err) {
            if (err.name === 'InvalidProjectWorkspace') {
                throw core_1.SfdxError.create('@salesforce/command', 'command', 'RequiresProjectError');
            }
            throw err;
        }
    }
    // Assign this.org if the command supports or requires a username.
    async assignOrg() {
        // Create an org from the username and set on this
        try {
            this.org = await core_1.Org.create(this.flags.targetusername, this.configAggregator);
        }
        catch (err) {
            if (this.constructor['requiresUsername']) {
                if (err.name === 'NoUsername') {
                    throw core_1.SfdxError.create('@salesforce/command', 'command', 'RequiresUsernameError');
                }
                throw err;
            }
        }
    }
    // Assign this.hubOrg if the command supports or requires a devhub username.
    async assignHubOrg() {
        // Create an org from the devhub username and set on this
        try {
            this.hubOrg = await core_1.Org.create(this.flags.targetdevhubusername, this.configAggregator, true);
        }
        catch (err) {
            // Throw an error if the command requires a devhub and there is no targetdevhubusername
            // flag set and no defaultdevhubusername set.
            if (this.constructor['requiresDevhubUsername']) {
                if (err.name === 'NoUsername') {
                    throw core_1.SfdxError.create('@salesforce/command', 'command', 'RequiresDevhubUsernameError');
                }
                throw err;
            }
        }
    }
    shouldEmitHelp() {
        // If -h was given and this command does not define its own flag with `char: 'h'`,
        // indicate that help should be emitted.
        if (!this.argv.includes('-h')) {
            // If -h was not given, nothing else to do here.
            return false;
        }
        // Check each flag config to see if -h has been overridden...
        const flags = this.ctor.flags;
        for (const k of Object.keys(flags)) {
            if (k !== 'help' && flags[k].char === 'h') {
                // If -h is configured for anything but help, the subclass should handle it itself.
                return false;
            }
        }
        // Otherwise, -h was either not overridden by the subclass, or the subclass includes a specific help flag config.
        return true;
    }
    async init() {
        // Ensure this.isJson, this.logger, and this.ux are set before super init, flag parsing, or help generation
        // (all of which can throw and prevent these from being available for command error handling).
        this.isJson = this.argv.includes('--json');
        // Regex match on loglevel flag in argv and set on the root logger so the proper log level
        // is used.  If no match, the default root log level is used.
        const loglevel = this.argv.join(' ').match(/--loglevel\s*=?\s*([a-z]+)/);
        if (loglevel) {
            (await core_1.Logger.root()).setLevel(core_1.Logger.getLevelByName(loglevel[1]));
        }
        this.logger = await core_1.Logger.child(this.constructor.name);
        this.ux = new ux_1.UX(this.logger, !this.isJson);
        this.result.ux = this.ux;
        // If the -h flag is set in argv and not overridden by the subclass, emit help and exit.
        if (this.shouldEmitHelp()) {
            this._help();
        }
        // Finally invoke the super init now that this.ux is properly configured.
        await super.init();
        // Load messages
        const messages = core_1.Messages.loadMessages('@salesforce/command', 'command');
        const ctor = this.constructor;
        // Turn off strict parsing if varargs are set.  Otherwise use static strict setting.
        const strict = ctor.varargs ? !ctor.varargs : ctor.strict;
        // Parse the command to get flags and args
        const { args, flags, argv } = this.parse({ flags: ctor.flags, args: ctor.args, strict });
        this.flags = flags;
        this.args = args;
        // If this command supports varargs, parse them from argv.
        if (ctor.varargs) {
            const argVals = Object.values(args);
            const varargs = argv.filter((val, i) => !argVals.includes(val));
            this.varargs = this.parseVarargs(varargs);
        }
        this.logger.info(`Running command [${ctor.name}] with flags [${JSON.stringify(flags)}] and args [${JSON.stringify(args)}]`);
        //
        // Verify the command args and flags meet the requirements
        //
        this.configAggregator = await core_1.ConfigAggregator.create();
        // Assign this.project if the command requires to be run from within a project.
        if (ctor.requiresProject) {
            await this.assignProject();
        }
        // Get the apiVersion from the config aggregator and display a warning
        // if it's overridden.
        const apiVersion = this.configAggregator.getInfo('apiVersion');
        if (apiVersion && apiVersion.value && !flags.apiversion) {
            this.ux.warn(messages.getMessage('apiVersionOverrideWarning', [apiVersion.value]));
        }
        // Assign this.org if the command supports or requires a username.
        if (ctor.supportsUsername || ctor.requiresUsername) {
            await this.assignOrg();
        }
        // Assign this.hubOrg if the command supports or requires a devhub username.
        if (ctor.supportsDevhubUsername || ctor.requiresDevhubUsername) {
            await this.assignHubOrg();
        }
    }
    // tslint:disable no-reserved-keywords
    async catch(err) {
        // Let oclif handle exit signal errors.
        if (err.code === 'EEXIT') {
            throw err;
        }
        // Convert all other errors to SfdxErrors for consistency and set the command name on the error.
        const error = (err instanceof core_1.SfdxError) ? err : core_1.SfdxError.wrap(err);
        error.setCommandName(this.constructor.name);
        process.exitCode = process.exitCode || error.exitCode || 1;
        const userDisplayError = Object.assign({}, error.toObject(), { stack: error.stack, status: error.exitCode, result: error.data, warnings: ux_1.UX.warnings });
        if (this.isJson) {
            this.ux.errorJson(userDisplayError);
        }
        else {
            this.ux.error(...this.formatError(error));
            if (err.data) {
                this.result.data = err.data;
                this.result.display();
            }
        }
    }
    async finally(err) {
        // Only handle success since we're handling errors in the catch
        if (!err) {
            if (this.isJson) {
                this.ux.logJson({ status: process.exitCode || 0, result: this.result.data });
            }
            else {
                this.result.display();
            }
        }
    }
    parseVarargs(args = []) {
        const ctor = this.constructor;
        // If this command requires varargs, throw if none are provided.
        if (kit_1.get(ctor, 'varargs.required') && !args.length) {
            throw core_1.SfdxError.create('@salesforce/command', 'command', 'VarargsRequired');
        }
        const varargs = {};
        // validate the format of the varargs
        if (args.length) {
            args.forEach(arg => {
                const split = arg.split('=');
                if (split.length !== 2) {
                    throw core_1.SfdxError.create('@salesforce/command', 'command', 'InvalidVarargsFormat', [arg]);
                }
                const [name, value] = split;
                if (varargs[name]) {
                    throw core_1.SfdxError.create('@salesforce/command', 'command', 'DuplicateVararg', [name]);
                }
                const validator = kit_1.get(ctor, 'varargs.validator');
                if (validator) {
                    validator(name, value);
                }
                varargs[name] = value || undefined;
            });
        }
        return varargs;
    }
    /**
     * Format errors and actions for human consumption. Adds 'ERROR running <command name>',
     * and outputs all errors in red.  When there are actions, we add 'Try this:' in blue
     * followed by each action in red on its own line.
     * @returns {string[]} Returns decorated messages.
     */
    formatError(error) {
        const colorizedArgs = [];
        const runningWith = error.commandName ? ` running ${error.commandName}` : '';
        colorizedArgs.push(chalk_1.default.bold(`ERROR${runningWith}: `));
        colorizedArgs.push(chalk_1.default.red(error.message));
        // Format any actions.
        if (kit_1.get(error, 'actions.length')) {
            colorizedArgs.push(`\n\n${chalk_1.default.blue(chalk_1.default.bold('Try this:'))}`);
            error.actions.forEach(action => {
                colorizedArgs.push(`\n${chalk_1.default.red(action)}`);
            });
        }
        if (error.stack && core_1.Global.getEnvironmentMode() === core_1.Mode.DEVELOPMENT) {
            colorizedArgs.push(chalk_1.default.red(`\n*** Internal Diagnostic ***\n\n${error.stack}\n******\n`));
        }
        return colorizedArgs;
    }
}
// Set to true to add the "targetusername" flag to this command.
SfdxCommand.supportsUsername = false;
// Set to true if this command MUST have a targetusername set, either via
// a flag or by having a default.
SfdxCommand.requiresUsername = false;
// Set to true to add the "targetdevhubusername" flag to this command.
SfdxCommand.supportsDevhubUsername = false;
// Set to true if this command MUST have a targetdevhubusername set, either via
// a flag or by having a default.
SfdxCommand.requiresDevhubUsername = false;
// Set to true if this command MUST be run within a SFDX project.
SfdxCommand.requiresProject = false;
// Use for full control over command output formating and display, or to override
// certain pieces of default display behavior.
SfdxCommand.result = {};
// Use to enable or configure varargs style (key=value) parameters.
SfdxCommand.varargs = false;
exports.SfdxCommand = SfdxCommand;
//# sourceMappingURL=sfdxCommand.js.map