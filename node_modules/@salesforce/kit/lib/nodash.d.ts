import { AnyFunction, ArrayLike, Dictionary, Many, Optional, PropertyKey } from '@salesforce/ts-types';
export { isBoolean, isNumber, isString, isObject, isPlainObject } from '@salesforce/ts-types';
/**
 * Assigns own enumerable properties of source object(s) to the destination object for all destination
 * properties that resolve to undefined. Once a property is set, additional values of the same property are
 * ignored.
 *
 * Note: This method mutates `obj`.
 *
 * @param obj The destination object.
 * @param sources The source objects.
 * @return {any}
 */
export declare function defaults<T, S>(obj: T, source: S): S & T;
/**
 * @see defaults
 */
export declare function defaults<T, S1, S2>(obj: T, source1: S1, source2: S2): S2 & S1 & T;
/**
 * @see defaults
 */
export declare function defaults<T, S1, S2, S3>(obj: T, source1: S1, source2: S2, source3: S3): S3 & S2 & S1 & T;
/**
 * @see defaults
 */
export declare function defaults<T, S1, S2, S3, S4>(obj: T, source1: S1, source2: S2, source3: S3, source4: S4): S4 & S3 & S2 & S1 & T;
/**
 * @see defaults
 */
export declare function defaults<T>(obj: T): T;
/**
 * This method is like `find` except that it returns the key of the first element predicate returns truthy for
 * instead of the element itself.
 *
 * @param obj The object to search.
 * @param predicate The function invoked per iteration.
 * @return {Optional<string>}
 */
export declare function findKey<T>(obj: T | null | undefined, predicate?: ObjectIteratee<T>): Optional<string>;
/**
 * Gets the property value at path of object. If the resolved value is undefined the defaultValue is used
 * in its place.
 *
 * @param obj The object to query.
 * @param path The path of the property to get.
 * @param def The value returned if the resolved value is undefined.
 * @return {any}
 */
export declare function get<T extends object>(obj: T | null | undefined, path: string): any;
/**
 * @see get
 */
export declare function get<T extends object, D>(obj: T | null | undefined, path: string, def: D): any | D;
/**
 * Checks if value is empty. A value is considered empty unless it’s an arguments object, array, string, or
 * jQuery-like collection with a length greater than 0 or an object with own enumerable properties.
 *
 * @param value The value to inspect.
 * @return {boolean}
 */
export declare function isEmpty(value?: any): boolean;
/**
 * Creates an object composed of keys generated from the results of running each element of collection through
 * iteratee. The corresponding value of each key is the last element responsible for generating the key. The
 * iteratee function is invoked with one argument: (value).
 *
 * @param collection The collection to iterate over.
 * @param iteratee The function invoked per iteration.
 * @return {Dictionary}
 */
export declare function keyBy<T>(collection: ArrayLike<T> | null | undefined, iteratee?: ValueIterateeCustom<T, PropertyKey>): Dictionary<T>;
/**
 * @see keyBy
 */
export declare function keyBy<T extends object>(collection: T | null | undefined, iteratee?: ValueIterateeCustom<T[keyof T], PropertyKey>): Dictionary<T[keyof T]>;
/**
 * Converts the first character of `string` to lower case.
 *
 * @param string The string to convert.
 * @return {Optional<string>}
 */
export declare function lowerFirst(value: string): string;
/**
 * @see lowerFirst
 */
export declare function lowerFirst(value?: string): Optional<string>;
/**
 * The opposite of _.mapValues; this method creates an object with the same values as object and keys generated
 * by running each own enumerable property of object through iteratee.
 *
 * @param obj The object to iterate over.
 * @param iteratee The function invoked per iteration.
 * @return {any}
 */
export declare function mapKeys<T>(object: ArrayLike<T> | null | undefined, iteratee?: ListIteratee<T>): Dictionary<T>;
/**
 * @see mapKeys
 */
export declare function mapKeys<T extends object>(object: T | null | undefined, iteratee?: ObjectIteratee<T>): Dictionary<T[keyof T]>;
/**
 * Creates an object with the same keys as object and values generated by running each own
 * enumerable property of object through iteratee. The iteratee function is
 * invoked with three arguments: (value, key, object).
 *
 * @param obj The object to iterate over.
 * @param iteratee The function invoked per iteration.
 * @return {any}
 */
export declare function mapValues<T, R>(obj: Dictionary<T> | null | undefined, callback: DictionaryIterator<T, R>): Dictionary<R>;
/**
 * @see mapValues
 */
export declare function mapValues<T extends object, R>(obj: T | null | undefined, callback: ObjectIterator<T, R>): {
    [P in keyof T]: R;
};
/**
 * @see mapValues
 */
export declare function mapValues<T>(obj: Dictionary<T> | null | undefined, iteratee: object): Dictionary<boolean>;
/**
 * @see mapValues
 */
export declare function mapValues<T extends object>(obj: T | null | undefined, iteratee: object): {
    [P in keyof T]: boolean;
};
/**
 * @see mapValues
 */
export declare function mapValues<T, K extends keyof T>(obj: Dictionary<T> | null | undefined, iteratee: K): Dictionary<T[K]>;
/**
 * @see mapValues
 */
export declare function mapValues<T>(obj: Dictionary<T> | null | undefined, iteratee: string): Dictionary<any>;
/**
 * @see mapValues
 */
export declare function mapValues<T extends object>(obj: T | null | undefined, iteratee: string): {
    [P in keyof T]: any;
};
/**
 * This method is like `_.min` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @param array The array to iterate over.
 * @param iteratee The iteratee invoked per element.
 * @returns {any}
 */
export declare function minBy<T>(collection: ArrayLike<T> | null | undefined, iteratee?: ValueIteratee<T>): Optional<T>;
/**
 * This method is like `_.max` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @param array The array to iterate over.
 * @param iteratee The iteratee invoked per element.
 * @returns Returns the maximum value.
 */
export declare function maxBy<T>(collection: ArrayLike<T> | null | undefined, iteratee?: ValueIteratee<T>): Optional<T>;
/**
 * Recursively merges own and inherited enumerable properties of source
 * objects into the destination object, skipping source properties that resolve
 * to `undefined`. Array and plain object properties are merged recursively.
 * Other objects and value types are overridden by assignment. Source objects
 * are applied from left to right. Subsequent sources overwrite property
 * assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @param object The destination object.
 * @param sources The source objects.
 * @returns {any}
 */
export declare function merge<T, S>(object: T, source: S): T & S;
/**
 * @see merge
 */
export declare function merge<T, S1, S2>(object: T, source1: S1, source2: S2): T & S1 & S2;
/**
 * @see merge
 */
export declare function merge<T, S1, S2, S3>(object: T, source1: S1, source2: S2, source3: S3): T & S1 & S2 & S3;
/**
 * @see merge
 */
export declare function merge<T, S1, S2, S3, S4>(object: T, source1: S1, source2: S2, source3: S3, source4: S4): T & S1 & S2 & S3 & S4;
/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable properties of `object` that are not omitted.
 *
 * @param obj The source object.
 * @param paths The property names to omit, specified individually or in arrays..
 * @returns {any}
 */
export declare function omit<T extends Dictionary>(obj: T | null | undefined, ...paths: Array<Many<PropertyKey>>): T;
/**
 * @see omit
 */
export declare function omit<T extends object, K extends keyof T>(obj: T | null | undefined, ...paths: Array<Many<K>>): Omit<T, K>;
/**
 * @see omit
 */
export declare function omit<T extends object>(obj: T | null | undefined, ...paths: Array<Many<PropertyKey>>): Partial<T>;
/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls to the function return the value
 * of the first call. The `func` is invoked with the this binding and arguments of the created function.
 *
 * @param func The function to restrict.
 * @return {Function}
 */
export declare function once<T extends AnyFunction>(func: T): T;
/**
 * Sets the value at path of object. If a portion of path doesn’t exist it’s created. Arrays are created for
 * missing index properties while objects are created for all other missing properties. Use _.setWith to
 * customize path creation.
 *
 * @param obj The object to modify.
 * @param path The path of the property to set.
 * @param value The value to set.
 * @return {any}
 */
export declare function set<T extends object>(obj: T, path: string, value: any): T;
/**
 * @see set
 */
export declare function set<R>(obj: object, path: string, value: any): R;
/**
 * Converts string to snake case.
 *
 * @param {string} str The string to convert.
 * @return {Optional<string>}
 */
export declare function snakeCase(str: string): string;
export declare function snakeCase(str?: string): Optional<string>;
/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection through each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @param collection The collection to iterate over.
 * @param iteratees The iteratees to sort by, specified individually or in arrays.
 * @returns {Array}
 */
export declare function sortBy<T>(collection: ArrayLike<T> | null | undefined, ...iteratees: Array<Many<ListIteratee<T>>>): T[];
/**
 * @see sortBy
 */
export declare function sortBy<T extends object>(collection: T | null | undefined, ...iteratees: Array<Many<ObjectIteratee<T>>>): Array<T[keyof T]>;
/**
 * Converts the first character of `string` to upper case.
 *
 * @param string The string to convert.
 * @return {Optional<string>}
 */
export declare function upperFirst(value: string): string;
/**
 * @see upperFirst
 */
export declare function upperFirst(value?: string): Optional<string>;
export declare type NotVoid = {} | null | undefined;
export declare type ValueIterateeCustom<T, R> = ((value: T) => R) | IterateeShorthand<T>;
export declare type IterateeShorthand<T> = PropertyKey | [PropertyKey, any] | PartialDeep<T>;
export declare type PartialDeep<T> = {
    [P in keyof T]?: PartialDeep<T[P]>;
};
export declare type ObjectIterator<T, R> = (value: T[keyof T], key: string, collection: T) => R;
export declare type ObjectIteratee<T> = ObjectIterator<T, NotVoid> | IterateeShorthand<T[keyof T]>;
export declare type ListIterator<T, R> = (value: T, index: number, collection: ArrayLike<T>) => R;
export declare type ListIteratee<T> = ListIterator<T, NotVoid> | IterateeShorthand<T>;
export declare type DictionaryIterator<T, TResult> = ObjectIterator<Dictionary<T>, TResult>;
export declare type ValueIteratee<T> = ((value: T) => NotVoid) | IterateeShorthand<T>;
export declare type Omit<T, K extends keyof T> = Pick<T, ({
    [P in keyof T]: P;
} & {
    [P in K]: never;
} & {
    [x: string]: never;
})[keyof T]>;
