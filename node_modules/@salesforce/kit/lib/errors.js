"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
class NamedError extends Error {
    constructor(name, messageOrCause, cause) {
        if (typeof messageOrCause === 'string') {
            super(messageOrCause);
            this.cause = cause;
        }
        else {
            super();
            this.cause = messageOrCause;
        }
        this.name = name;
    }
    get fullStack() {
        let stack = this.stack;
        if (this.cause && (this.cause.fullStack || this.cause.stack)) {
            stack = `${stack ? stack + '\n' : ''}Caused by: ${this.cause.fullStack || this.cause.stack}`;
        }
        return stack;
    }
}
exports.NamedError = NamedError;
class JsonParseError extends NamedError {
    constructor(cause, path, line, errorPortion) {
        super('JsonParseError', JsonParseError.format(cause, path, line, errorPortion), cause);
        this.path = path;
        this.line = line;
        this.errorPortion = errorPortion;
    }
    static create(error, data, jsonPath) {
        if (error.name !== 'SyntaxError') {
            throw error;
        }
        // Get the position of the error from the error message.  This is the error index
        // within the file contents as 1 long string.
        const positionMatch = error.message.match(/position (\d+)/);
        if (!positionMatch) {
            return new JsonParseError(error, jsonPath);
        }
        const errPosition = parseInt(positionMatch[1], 10);
        // Get a buffered error portion to display.
        const BUFFER = 20;
        const start = Math.max(0, (errPosition - BUFFER));
        const end = Math.min(data.length, (errPosition + BUFFER));
        const errorPortion = data.slice(start, end);
        // Only need to count new lines before the error position.
        const lineNumber = data.slice(0, errPosition).split('\n').length;
        return new JsonParseError(error, jsonPath, lineNumber, errorPortion);
    }
    static format(cause, path, line, errorPortion) {
        if (line == null)
            return cause.message || 'Unknown cause';
        return `Parse error in file ${path} on line ${line}\n${errorPortion}`;
    }
}
exports.JsonParseError = JsonParseError;
class JsonStringifyError extends NamedError {
    constructor(cause) {
        super('JsonStringifyError', cause);
    }
}
exports.JsonStringifyError = JsonStringifyError;
class JsonDataFormatError extends NamedError {
    constructor(message) {
        super('JsonDataFormatError', message);
    }
}
exports.JsonDataFormatError = JsonDataFormatError;
class InvalidDefaultEnvValueError extends NamedError {
    constructor(message) {
        super('InvalidDefaultEnvValueError', message);
    }
}
exports.InvalidDefaultEnvValueError = InvalidDefaultEnvValueError;
//# sourceMappingURL=errors.js.map