"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
// @ts-ignore ignore the demand for typings for the locally built lodash
const _ = require("./lodash");
var ts_types_1 = require("@salesforce/ts-types");
exports.isBoolean = ts_types_1.isBoolean;
exports.isNumber = ts_types_1.isNumber;
exports.isString = ts_types_1.isString;
exports.isObject = ts_types_1.isObject;
exports.isPlainObject = ts_types_1.isPlainObject;
function defaults(obj, ...otherArgs) {
    return _.defaults(obj, ...otherArgs);
}
exports.defaults = defaults;
/**
 * This method is like `find` except that it returns the key of the first element predicate returns truthy for
 * instead of the element itself.
 *
 * @param obj The object to search.
 * @param predicate The function invoked per iteration.
 * @return {Optional<string>}
 */
function findKey(obj, predicate) {
    return _.findKey(obj, predicate);
}
exports.findKey = findKey;
function get(obj, path, def) {
    return _.get(obj, path, def);
}
exports.get = get;
/**
 * Checks if value is empty. A value is considered empty unless itâ€™s an arguments object, array, string, or
 * jQuery-like collection with a length greater than 0 or an object with own enumerable properties.
 *
 * @param value The value to inspect.
 * @return {boolean}
 */
function isEmpty(value) {
    if (value == null)
        return true;
    if (util_1.isNumber(value) || util_1.isBoolean(value))
        return false;
    if (value.length > 0)
        return false;
    if (value.size > 0)
        return false;
    if (Object.keys(value).length > 0)
        return false;
    return true;
}
exports.isEmpty = isEmpty;
function keyBy(collection, iteratee) {
    return _.keyBy(collection, iteratee);
}
exports.keyBy = keyBy;
function lowerFirst(value) {
    return value && value.charAt(0).toLowerCase() + value.slice(1);
}
exports.lowerFirst = lowerFirst;
function mapKeys(obj, iteratee) {
    return _.mapKeys(obj, iteratee);
}
exports.mapKeys = mapKeys;
function mapValues(obj, iteratee) {
    return _.mapValues(obj, iteratee);
}
exports.mapValues = mapValues;
/**
 * This method is like `_.min` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @param array The array to iterate over.
 * @param iteratee The iteratee invoked per element.
 * @returns {any}
 */
function minBy(collection, iteratee) {
    return _.minBy(collection, iteratee);
}
exports.minBy = minBy;
/**
 * This method is like `_.max` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @param array The array to iterate over.
 * @param iteratee The iteratee invoked per element.
 * @returns Returns the maximum value.
 */
function maxBy(collection, iteratee) {
    return _.maxBy(collection, iteratee);
}
exports.maxBy = maxBy;
function merge(obj, ...otherArgs) {
    return _.merge(obj, ...otherArgs);
}
exports.merge = merge;
function omit(obj, ...paths) {
    return _.omit(obj, ...paths);
}
exports.omit = omit;
/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls to the function return the value
 * of the first call. The `func` is invoked with the this binding and arguments of the created function.
 *
 * @param func The function to restrict.
 * @return {Function}
 */
function once(func) {
    return _.once(func);
}
exports.once = once;
function set(obj, path, value) {
    return _.set(obj, path, value);
}
exports.set = set;
function snakeCase(str) {
    return str && str.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase().replace(/\W/g, '_').replace(/^_+|_+$/g, '');
}
exports.snakeCase = snakeCase;
function sortBy(collection, ...iteratees) {
    return _.sortBy(collection, ...iteratees);
}
exports.sortBy = sortBy;
function upperFirst(value) {
    return value && value.charAt(0).toUpperCase() + value.slice(1);
}
exports.upperFirst = upperFirst;
//# sourceMappingURL=nodash.js.map