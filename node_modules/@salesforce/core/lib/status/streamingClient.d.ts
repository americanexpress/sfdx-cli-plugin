/// <reference types="node" />
import { Dictionary, JsonMap } from '@salesforce/ts-types';
import { EventEmitter } from 'events';
import { Org } from '../org';
import { Time } from '../util/time';
import { StatusResult } from './client';
/**
 * Comet client interface. The is to allow for mocking the inner streaming Cometd implementation.
 * The Faye implementation is used by default but it could be used to adapt another Cometd impl.
 * @abstract
 */
export declare abstract class CometClient extends EventEmitter {
    /**
     * Disable polling features.
     * @param {string} label Polling feature label.
     * @abstract
     */
    abstract disable(label: string): void;
    /**
     * Add a custom extension to the underlying client.
     * @param {JsonMap} extension The json function for the extension.
     * @abstract
     */
    abstract addExtension(extension: Dictionary): void;
    /**
     * Sets an http header name/value.
     * @param {string} name The header name.
     * @param {string} value The header value.
     * @abstract
     */
    abstract setHeader(name: string, value: string): void;
    /**
     * handshake with the streaming channel
     * @param {function} callback Callback for the handshake when it successfully completes. The handshake should throw
     * errors when errors are encountered.
     * @abstract
     */
    abstract handshake(callback: () => void): void;
    /**
     * Subscribes to Comet topics. Subscribe should perform a handshake if one hasn't been performed yet.
     * @param {string} channel The topic to subscribe to.
     * @param {function(message)} callback The callback to execute once a message has been received.
     * @returns {CometSubscription} A subscription object.
     */
    abstract subscribe(channel: string, callback: (message: JsonMap) => void): CometSubscription;
    abstract disconnect(): void;
}
/**
 * Inner streaming client interface. This implements the Cometd behavior.
 * Also allows for mocking the functional behavior.
 * @interface
 */
export interface StreamingClientIfc {
    getCometClient: (url: string) => CometClient;
    setLogger: (logLine: (message: string) => void) => void;
}
/**
 * The subscription object returned from the cometd subscribe object.
 */
export interface CometSubscription {
    callback(callback: () => void): void;
    errback(callback: (error: Error) => void): void;
}
/**
 * Options for the StreamingClient
 * @interface
 */
export interface StreamingOptions<T> {
    org: Org;
    subscribeTimeout: Time;
    handshakeTimeout: Time;
    channel: string;
    apiVersion: string;
    streamProcessor: (message: JsonMap) => StatusResult<T>;
    streamingImpl: StreamingClientIfc;
}
/**
 * Default Streaming Options. Uses Faye as the cometd impl.
 */
export declare class DefaultStreamingOptions<T> implements StreamingOptions<T> {
    static readonly DEFAULT_SUBSCRIBE_TIMEOUT: Time;
    static readonly DEFAULT_HANDSHAKE_TIMEOUT: Time;
    apiVersion: string;
    org: Org;
    streamProcessor: (message: JsonMap) => StatusResult<T>;
    subscribeTimeout: Time;
    handshakeTimeout: Time;
    channel: string;
    streamingImpl: StreamingClientIfc;
    /**
     * Constructor for DefaultStreamingOptions
     * @param {Org} org The streaming target org
     * @param {string} channel The streaming channel or topic. If the topic is a system topic then api 36.0 is used.
     * System topics are deprecated.
     * @param {function(JsonMap)} streamProcessor The function called that can process streaming messages.
     * @see {@link StatusResult}
     */
    constructor(org: Org, channel: string, streamProcessor: (message: JsonMap) => StatusResult<T>);
    /**
     * Setter for the subscribe timeout.
     * @param {Time} newTime The new subscribe timeout.
     * @throws {SfdxError} An error if the newTime is less than the default time.
     */
    setSubscribeTimeout(newTime: Time): void;
    /**
     * Setter for the handshake timeout.
     * @param {Time} newTime The new handshake timeout
     * @throws {SfdxError} An error if the newTime is less than the default time.
     */
    setHandshakeTimeout(newTime: Time): void;
    private validateTimeout;
}
/**
 * Connection state
 * @typedef StreamingConnectionState
 * @property {string} CONNECTED Used to indicated that the streaming client is connected.
 * @see {@link StreamingClient.handshake}
 */
export declare enum StreamingConnectionState {
    CONNECTED = 0
}
/**
 * Indicators to test error names for StreamingTimeouts
 */
export declare enum StreamingTimeoutErrorType {
    HANDSHAKE = "genericHandshakeTimeoutMessage",
    SUBSCRIBE = "genericTimeoutMessage"
}
/**
 * Api wrapper to support Salesforce streaming. The client contains an internal implementation of a cometd specification.
 *
 * Salesforce client and timeout information
 *
 * Streaming API imposes two timeouts, as supported in the Bayeux protocol.
 *
 * Socket timeout: 110 seconds
 * A client receives events (JSON-formatted HTTP responses) while it waits on a connection. If no events are generated
 * and the client is still waiting, the connection times out after 110 seconds and the server closes the connection.
 * Clients should reconnect before two minutes to avoid the connection timeout.
 *
 * Reconnect timeout: 40 seconds
 * After receiving the events, a client needs to reconnect to receive the next set of events. If the reconnection
 * doesn't happen within 40 seconds, the server expires the subscription and the connection is closed. If this happens,
 * the client must start again and handshake, subscribe, and connect. Each Streaming API client logs into an instance
 * and maintains a session. When the client handshakes, connects, or subscribes, the session timeout is restarted. A
 * client session times out if the client doesnâ€™t reconnect to the server within 40 seconds after receiving a response
 * (an event, subscribe result, and so on).
 *
 * Note that these timeouts apply to the Streaming API client session and not the Salesforce authentication session. If
 * the client session times out, the authentication session remains active until the organization-specific timeout
 * policy goes into effect.
 *
 * @example
 *
 *  streamProcessor(message: JsonMap): StatusResult<string> {
 *      const payload = ensureJsonMap(message.payload);
 *      const id = ensureString(payload.id);
 *
 *      if (payload.status !== 'Active') {
 *          return  { completed: false };
 *      }
 *
 *      return {
 *          completed: true,
 *          payload: id
 *      };
 *  }
 *
 *  const org: Org = await Org.create(this.org.name);
 *  const options: StreamingOptions<string> =
 *      new DefaultStreamingOptions(org, TOPIC, this.streamProcessor);
 *
 *  try  {
 *      const asyncStatusClient: StreamingClient<string> = await StreamingClient.init(options);
 *
 *      await asyncStatusClient.handshake();
 *
 *      await asyncStatusClient.subscribe(async () => {
 *               // Now that we are subscribed, we can initiate the request that will cause the events to start streaming.
 *               const requestResponse = asJsonMap(asAnyJson(await org.getConnection().request(url)));
 *               this.id = ensureString(requestResponse.id);
 *           });
 *
 *  } catch(e) {
 *      // handle streaming message errors and timeouts here. ex. If the handshake fails you could try polling.
 *      // ....
 *  }
 *
 */
export declare class StreamingClient<T> {
    /**
     * A static initializer for creating a StreamingClient
     * @param {StreamingOptions<U>} options The StreamingClient options.
     * @returns {Promise<StreamingClient<U>>}
     */
    static init<U>(options: StreamingOptions<U>): Promise<StreamingClient<U>>;
    private readonly targetUrl;
    private readonly options;
    private logger;
    private cometClient;
    /**
     * Constructs a streaming client.
     * @param {StreamingOptions<T>} options Config options for the StreamingClient
     * @param {Logger} logger The child logger to use for streaming.
     * @see {@link StreamingOptions}
     * @private
     */
    private constructor();
    replay(replayId: number): void;
    /**
     * Provides a convenient way to handshake with the server endpoint before trying to subscribe.
     * @async
     * @returns {Promise<StreamingConnectionState>}
     */
    handshake(): Promise<StreamingConnectionState>;
    /**
     * Subscribe to streaming events.
     * @param {function} [streamInit] - This function should call the platform apis that result in streaming updates on push topics.
     * @returns {Promise<T>} - When the streaming processor that's set in the options completes, it returns a payload in
     * the StatusResult object. The payload is just echoed here for convenience.
     * @async
     * @see {@link StatusResult}
     */
    subscribe(streamInit?: () => Promise<void>): Promise<T>;
    private incoming;
    private doTimeout;
    private disconnect;
    /**
     * Simple inner log wrapper
     * @param {any} message The message to log
     * @private
     */
    private log;
}
