"use strict";
/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const timers_1 = require("timers");
const logger_1 = require("../logger");
const sfdxError_1 = require("../sfdxError");
const time_1 = require("../util/time");
/**
 * Default options set for polling. The default options specify a timeout of 3 minutes and polling frequency of 15
 * seconds;
 */
class DefaultPollingOptions {
    /**
     * constructor
     * @param {function} poll The function used for polling status.
     * @see StatusResult
     */
    constructor(poll) {
        this.poll = poll;
        this.timeout = new time_1.Time(3, time_1.TIME_UNIT.MINUTES);
        this.frequency = new time_1.Time(15, time_1.TIME_UNIT.SECONDS);
    }
}
exports.DefaultPollingOptions = DefaultPollingOptions;
/**
 * This is a polling client that can be used to poll the status of long running tasks. It can be used as a replacement
 * for Streaming when streaming topics are not available or when streaming handshakes are failing. Why wouldn't you
 * want to use this? It can impact Salesforce API usage.
 *
 * @example
 *  const options: PollingOptions<string> = {
 *
 *      async poll(): Promise<StatusResult<string>>  {
 *          return Promise.resolve(doSoqlQuery();
 *      },
 *      frequency: new Time(10, TIME_UNIT.MILLISECONDS),
 *      timeout: new Time(1, TIME_UNIT.MINUTES)
 *  };
 *
 *  const client = new PollingClient(options);
 *
 *  const pollResult: string = await client.subscribe();
 *
 *  // do Something with pollResult
 *  ...
 */
class PollingClient {
    /**
     * Constructor
     * @param {PollingOptions<T>} options Polling client options
     * @param {Logger} logger Internal logging instace
     * @see {@link PollingClient.init}
     */
    constructor(options, logger) {
        this.options = options;
        this.logger = logger;
        this.logger.debug('Polling enabled.');
    }
    /**
     * Initialize and return a polling client.
     *
     * @param {PollingOptions<U>} options Polling options.
     * @returns {Promise<PollingClient<U>>}
     * @see {@link PollingOptions}
     * @see {@link DefaultPollingOptions}
     * @async
     */
    static async init(options) {
        return new PollingClient(options, await logger_1.Logger.child('PollingClient'));
    }
    /**
     * Returns a promise to call the specified polling function using the interval and timeout specified
     * in the polling options.
     * @returns {Promise<T>} A promise to call the specified polling function using the interval and timeout specified
     * in the polling options.
     * @async
     */
    subscribe() {
        return new Promise((resolve, reject) => {
            // Use set interval to periodically call the polling function
            this.interval = timers_1.setInterval(async () => {
                try {
                    // Poll can be an async function.
                    const sample = await this.options.poll();
                    if (sample.completed) {
                        this.clearAll();
                        resolve(sample.payload);
                    }
                }
                catch (e) {
                    this.clearAll();
                    reject(e);
                }
            }, this.options.frequency.milliseconds);
            // hard polling timeout.
            this.timeout = setTimeout(() => {
                this.clearAll();
                // @todo should go in messages.
                reject(new sfdxError_1.SfdxError('The client has timed out.', 'ClientTimeout'));
            }, this.options.timeout.milliseconds);
        });
    }
    clearAll() {
        if (this.interval) {
            clearInterval(this.interval);
        }
        if (this.timeout) {
            clearTimeout(this.timeout);
        }
    }
}
exports.PollingClient = PollingClient;
//# sourceMappingURL=pollingClient.js.map