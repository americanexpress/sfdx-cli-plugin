"use strict";
/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const events_1 = require("events");
// @ts-ignore No typings are available for faye
const Faye = require("faye");
const logger_1 = require("../logger");
const sfdxError_1 = require("../sfdxError");
const time_1 = require("../util/time");
/**
 * Comet client interface. The is to allow for mocking the inner streaming Cometd implementation.
 * The Faye implementation is used by default but it could be used to adapt another Cometd impl.
 * @abstract
 */
class CometClient extends events_1.EventEmitter {
}
exports.CometClient = CometClient;
/**
 * Default Streaming Options. Uses Faye as the cometd impl.
 */
class DefaultStreamingOptions {
    /**
     * Constructor for DefaultStreamingOptions
     * @param {Org} org The streaming target org
     * @param {string} channel The streaming channel or topic. If the topic is a system topic then api 36.0 is used.
     * System topics are deprecated.
     * @param {function(JsonMap)} streamProcessor The function called that can process streaming messages.
     * @see {@link StatusResult}
     */
    constructor(org, channel, streamProcessor) {
        if (!streamProcessor) {
            throw new sfdxError_1.SfdxError('Missing stream processor', 'MissingArg');
        }
        if (!org) {
            throw new sfdxError_1.SfdxError('Missing org', 'MissingArg');
        }
        if (!channel) {
            throw new sfdxError_1.SfdxError('Missing streaming channel', 'MissingArg');
        }
        this.org = org;
        this.apiVersion = org.getConnection().getApiVersion();
        if (channel.startsWith('/system')) {
            this.apiVersion = '36.0';
        }
        this.streamProcessor = streamProcessor;
        this.channel = channel;
        this.subscribeTimeout = DefaultStreamingOptions.DEFAULT_SUBSCRIBE_TIMEOUT;
        this.handshakeTimeout = DefaultStreamingOptions.DEFAULT_HANDSHAKE_TIMEOUT;
        this.streamingImpl = {
            getCometClient: (url) => {
                return new Faye.Client(url);
            },
            setLogger: (logLine) => {
                Faye.logger = {};
                ['info', 'error', 'fatal', 'warn', 'debug'].forEach(element => {
                    kit_1.set(Faye.logger, element, logLine);
                });
            }
        };
    }
    /**
     * Setter for the subscribe timeout.
     * @param {Time} newTime The new subscribe timeout.
     * @throws {SfdxError} An error if the newTime is less than the default time.
     */
    setSubscribeTimeout(newTime) {
        this.subscribeTimeout = this.validateTimeout(newTime, DefaultStreamingOptions.DEFAULT_SUBSCRIBE_TIMEOUT);
    }
    /**
     * Setter for the handshake timeout.
     * @param {Time} newTime The new handshake timeout
     * @throws {SfdxError} An error if the newTime is less than the default time.
     */
    setHandshakeTimeout(newTime) {
        this.handshakeTimeout = this.validateTimeout(newTime, DefaultStreamingOptions.DEFAULT_HANDSHAKE_TIMEOUT);
    }
    validateTimeout(newTime, existingTime) {
        if (newTime.milliseconds >= existingTime.milliseconds) {
            return newTime;
        }
        throw sfdxError_1.SfdxError.create('@salesforce/core', 'streaming', 'waitParamValidValueError', [existingTime.minutes]);
    }
}
DefaultStreamingOptions.DEFAULT_SUBSCRIBE_TIMEOUT = new time_1.Time(3, time_1.TIME_UNIT.MINUTES);
DefaultStreamingOptions.DEFAULT_HANDSHAKE_TIMEOUT = new time_1.Time(30, time_1.TIME_UNIT.SECONDS);
exports.DefaultStreamingOptions = DefaultStreamingOptions;
/**
 * Connection state
 * @typedef StreamingConnectionState
 * @property {string} CONNECTED Used to indicated that the streaming client is connected.
 * @see {@link StreamingClient.handshake}
 */
var StreamingConnectionState;
(function (StreamingConnectionState) {
    StreamingConnectionState[StreamingConnectionState["CONNECTED"] = 0] = "CONNECTED";
})(StreamingConnectionState = exports.StreamingConnectionState || (exports.StreamingConnectionState = {}));
/**
 * Indicators to test error names for StreamingTimeouts
 */
var StreamingTimeoutErrorType;
(function (StreamingTimeoutErrorType) {
    StreamingTimeoutErrorType["HANDSHAKE"] = "genericHandshakeTimeoutMessage";
    StreamingTimeoutErrorType["SUBSCRIBE"] = "genericTimeoutMessage";
})(StreamingTimeoutErrorType = exports.StreamingTimeoutErrorType || (exports.StreamingTimeoutErrorType = {}));
/**
 * Api wrapper to support Salesforce streaming. The client contains an internal implementation of a cometd specification.
 *
 * Salesforce client and timeout information
 *
 * Streaming API imposes two timeouts, as supported in the Bayeux protocol.
 *
 * Socket timeout: 110 seconds
 * A client receives events (JSON-formatted HTTP responses) while it waits on a connection. If no events are generated
 * and the client is still waiting, the connection times out after 110 seconds and the server closes the connection.
 * Clients should reconnect before two minutes to avoid the connection timeout.
 *
 * Reconnect timeout: 40 seconds
 * After receiving the events, a client needs to reconnect to receive the next set of events. If the reconnection
 * doesn't happen within 40 seconds, the server expires the subscription and the connection is closed. If this happens,
 * the client must start again and handshake, subscribe, and connect. Each Streaming API client logs into an instance
 * and maintains a session. When the client handshakes, connects, or subscribes, the session timeout is restarted. A
 * client session times out if the client doesnâ€™t reconnect to the server within 40 seconds after receiving a response
 * (an event, subscribe result, and so on).
 *
 * Note that these timeouts apply to the Streaming API client session and not the Salesforce authentication session. If
 * the client session times out, the authentication session remains active until the organization-specific timeout
 * policy goes into effect.
 *
 * @example
 *
 *  streamProcessor(message: JsonMap): StatusResult<string> {
 *      const payload = ensureJsonMap(message.payload);
 *      const id = ensureString(payload.id);
 *
 *      if (payload.status !== 'Active') {
 *          return  { completed: false };
 *      }
 *
 *      return {
 *          completed: true,
 *          payload: id
 *      };
 *  }
 *
 *  const org: Org = await Org.create(this.org.name);
 *  const options: StreamingOptions<string> =
 *      new DefaultStreamingOptions(org, TOPIC, this.streamProcessor);
 *
 *  try  {
 *      const asyncStatusClient: StreamingClient<string> = await StreamingClient.init(options);
 *
 *      await asyncStatusClient.handshake();
 *
 *      await asyncStatusClient.subscribe(async () => {
 *               // Now that we are subscribed, we can initiate the request that will cause the events to start streaming.
 *               const requestResponse = asJsonMap(asAnyJson(await org.getConnection().request(url)));
 *               this.id = ensureString(requestResponse.id);
 *           });
 *
 *  } catch(e) {
 *      // handle streaming message errors and timeouts here. ex. If the handshake fails you could try polling.
 *      // ....
 *  }
 *
 */
class StreamingClient {
    /**
     * Constructs a streaming client.
     * @param {StreamingOptions<T>} options Config options for the StreamingClient
     * @param {Logger} logger The child logger to use for streaming.
     * @see {@link StreamingOptions}
     * @private
     */
    constructor(options, logger) {
        this.logger = logger;
        this.options = options;
        const instanceUrl = ts_types_1.ensure(options.org.getConnection().getAuthInfoFields().instanceUrl);
        const urlElements = [instanceUrl, 'cometd', options.apiVersion];
        this.targetUrl = urlElements.join('/');
        this.cometClient = this.options.streamingImpl.getCometClient(this.targetUrl);
        this.options.streamingImpl.setLogger(this.log.bind(this));
        this.cometClient.on('transport:up', () => this.log('Transport up event received'));
        this.cometClient.on('transport:down', () => this.log('Transport down event received'));
        this.cometClient.addExtension({
            incoming: this.incoming.bind(this)
        });
        this.cometClient.disable('websocket');
    }
    /**
     * A static initializer for creating a StreamingClient
     * @param {StreamingOptions<U>} options The StreamingClient options.
     * @returns {Promise<StreamingClient<U>>}
     */
    static async init(options) {
        // get the apiVersion from the connection if not already an option
        const conn = options.org.getConnection();
        options.apiVersion = options.apiVersion || conn.getApiVersion();
        const streamingClient = new StreamingClient(options, await logger_1.Logger.child('StreamingClient'));
        await streamingClient.options.org.refreshAuth();
        const accessToken = conn.getConnectionOptions().accessToken;
        if (accessToken && accessToken.length > 5) {
            streamingClient.logger.debug(`accessToken: XXXXXX${accessToken.substring(accessToken.length - 5, accessToken.length - 1)}`);
            streamingClient.cometClient.setHeader('Authorization', `OAuth ${accessToken}`);
        }
        else {
            throw new sfdxError_1.SfdxError('Missing or invalid access token', 'MissingOrInvalidAccessToken');
        }
        streamingClient.log(`Streaming client target url: ${streamingClient.targetUrl}`);
        streamingClient.log(`options.subscribeTimeout (ms): ${options.subscribeTimeout.milliseconds}`);
        streamingClient.log(`options.handshakeTimeout (ms): ${options.handshakeTimeout.milliseconds}`);
        return streamingClient;
    }
    replay(replayId) {
        this.cometClient.addExtension({
            outgoing: (message, callback) => {
                if (message.channel === '/meta/subscribe') {
                    if (!message.ext) {
                        message.ext = {};
                    }
                    const replayFromMap = {};
                    replayFromMap[this.options.channel] = replayId;
                    // add "ext : { "replay" : { CHANNEL : REPLAY_VALUE }}" to subscribe message
                    message.ext['replay'] = replayFromMap;
                }
                callback(message);
            }
        });
    }
    /**
     * Provides a convenient way to handshake with the server endpoint before trying to subscribe.
     * @async
     * @returns {Promise<StreamingConnectionState>}
     */
    handshake() {
        let timeout;
        return new Promise((resolve, reject) => {
            timeout = setTimeout(() => {
                const timeoutError = sfdxError_1.SfdxError.create('@salesforce/core', 'streaming', StreamingTimeoutErrorType.HANDSHAKE, [this.targetUrl]);
                this.doTimeout(timeout, timeoutError);
                reject(timeoutError);
            }, this.options.handshakeTimeout.milliseconds);
            this.cometClient.handshake(() => {
                this.log('handshake completed');
                clearTimeout(timeout);
                this.log('cleared handshake timeout');
                resolve(StreamingConnectionState.CONNECTED);
            });
        });
    }
    /**
     * Subscribe to streaming events.
     * @param {function} [streamInit] - This function should call the platform apis that result in streaming updates on push topics.
     * @returns {Promise<T>} - When the streaming processor that's set in the options completes, it returns a payload in
     * the StatusResult object. The payload is just echoed here for convenience.
     * @async
     * @see {@link StatusResult}
     */
    subscribe(streamInit) {
        let timeout;
        // This outer promise is to hold the streaming promise chain open until the streaming processor
        // says it's complete.
        return new Promise((subscribeResolve, subscribeReject) => {
            // This is the inner promise chain that's satisfied when the client impl (Faye/Mock) says it's subscribed.
            return new Promise((subscriptionResolve, subscriptionReject) => {
                timeout = setTimeout(() => {
                    const timeoutError = sfdxError_1.SfdxError.create('@salesforce/core', 'streaming', StreamingTimeoutErrorType.SUBSCRIBE);
                    this.doTimeout(timeout, timeoutError);
                    subscribeReject(timeoutError);
                }, this.options.subscribeTimeout.milliseconds);
                // Initialize the subscription.
                const subscription = this.cometClient.subscribe(this.options.channel, message => {
                    try {
                        // The result of the stream processor determines the state of the outer promise.
                        const result = this.options.streamProcessor(message);
                        // The stream processor says it's complete. Clean up and resolve the outer promise.
                        if (result && result.completed) {
                            clearTimeout(timeout);
                            this.cometClient.disconnect();
                            subscribeResolve(result.payload);
                        }
                    }
                    catch (e) {
                        // it's completely valid for the stream processor to throw an error. If it does we will
                        // reject the outer promise. Keep in mind if we are here the subscription was resolved.
                        clearTimeout(timeout);
                        subscribeReject(e);
                    }
                });
                subscription.callback(() => {
                    subscriptionResolve();
                });
                subscription.errback(error => {
                    subscriptionReject(error);
                });
            })
                .then(() => {
                // Now that we successfully have a subscription started up we are safe to initialize the function that
                // will affect the streaming events. I.E. create an org or run apex tests.
                return streamInit && streamInit();
            })
                .catch(error => {
                // Need to catch the subscription rejection or it will result in an unhandled rejection error.
                clearTimeout(timeout);
                // No subscription so we can reject the out promise as well.
                subscribeReject(error);
            });
        });
    }
    incoming(message, cb) {
        this.log(message);
        // Look for a specific error message during the handshake.  If found, throw an error
        // with actions for the user.
        if (message &&
            message.channel === '/meta/handshake' &&
            message.error &&
            message.error.includes('400::API version in the URI is mandatory')) {
            const errConfig = new sfdxError_1.SfdxErrorConfig('@salesforce/core', 'streaming', 'handshakeApiVersionError', [this.options.apiVersion], 'handshakeApiVersionErrorAction');
            throw sfdxError_1.SfdxError.create(errConfig);
        }
        cb(message);
    }
    doTimeout(timeout, error) {
        this.disconnect();
        clearTimeout(timeout);
        this.log(JSON.stringify(error));
        return error;
    }
    disconnect() {
        // This is a patch for faye. If Faye encounters errors while attempting to handshake it will keep trying
        // and will prevent the timeout from disconnecting. Here for example we will detect there is no client id but
        // unauthenticated connections are being made to salesforce. Let's close the dispatcher if it exists and
        // has no clientId.
        // @ts-ignore
        if (this.cometClient._dispatcher) {
            this.log('Closing the faye dispatcher');
            // @ts-ignore
            const dispatcher = this.cometClient._dispatcher;
            this.log(`dispatcher.clientId: ${dispatcher.clientId}`);
            if (!dispatcher.clientId) {
                dispatcher.close();
            }
            else {
                this.cometClient.disconnect();
            }
        }
    }
    /**
     * Simple inner log wrapper
     * @param {any} message The message to log
     * @private
     */
    log(message) {
        if (this.logger) {
            this.logger.debug(message);
        }
    }
}
exports.StreamingClient = StreamingClient;
//# sourceMappingURL=streamingClient.js.map