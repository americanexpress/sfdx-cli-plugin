/**
 * Contains meta information about sfdx config properties.
 * @typedef {object} ConfigPropertyMeta
 * @property {string} key The config property name.
 * @property {input} value Reference to the config data input validation.
 * @property {boolean} hidden True if the property should be indirectly hidden from the user.
 * @property {boolean} encrypted True if the property values should be stored encrypted.
 */
/**
 * Contains meta information about sfdx config properties.
 * @typedef {object} ConfigPropertyMetaInput
 * @property {function} validator Test if the input value is valid.
 * @property {string} failedMessage The message to return in the error if the validation fails.
 */
/**
 * Supported Org Default Types.
 * @typedef {object} ORG_DEFAULT
 * @property {string} DEVHUB Default developer hub username.
 * @property {string} USERNAME Default username.
 * @property {function} list `() => string[]` List the Org defaults.
 */
import { ConfigFile, ConfigOptions } from './configFile';
import { ConfigContents, ConfigValue } from './configStore';
/**
 * Interface for meta information about config properties
 */
export interface ConfigPropertyMeta {
    /**
     *  The config property name.
     */
    key: string;
    /**
     *  Reference to the config data input validation.
     */
    input?: ConfigPropertyMetaInput;
    /**
     *  True if the property should be indirectly hidden from the user.
     */
    hidden?: boolean;
    /**
     * True if the property values should be stored encrypted.
     */
    encrypted?: boolean;
}
/**
 * Config property input validation
 */
export interface ConfigPropertyMetaInput {
    /**
     * Test if the input value is valid.
     * @param value The input value.
     * @returns {boolean} Returns true if the input data is valid.
     */
    validator: (value: ConfigValue) => boolean;
    /**
     * The message to return in the error if the validation fails.
     */
    failedMessage: string;
}
/**
 * The files where sfdx config values are stored for projects and the global space.
 *
 * *Note:* It is not recommended to instantiate this object directly when resolving
 * config values. Instead use {@link ConfigAggregator}
 *
 * @extends ConfigFile
 *
 * @example
 * const localConfig = await Config.retrieve<Config>();
 * localConfig.set('defaultusername', 'username@company.org');
 * await localConfig.write();
 *
 * @see https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_cli_config_values.htm
 */
export declare class Config extends ConfigFile {
    /**
     * Username associated with the default dev hub org.
     * @type {string}
     */
    static readonly DEFAULT_DEV_HUB_USERNAME: string;
    /**
     * Username associate with the default org.
     * @type {string}
     */
    static readonly DEFAULT_USERNAME: string;
    /**
     * The sid for the debugger configuration.
     * @type {string}
     */
    static readonly ISV_DEBUGGER_SID: string;
    /**
     * The url for the debugger configuration.
     * @type {string}
     */
    static readonly ISV_DEBUGGER_URL: string;
    /**
     * true if polling should be used over streaming when creating scratch orgs.
     * @type {string}
     */
    static readonly USE_BACKUP_POLLING_ORG_CREATE: string;
    /**
     * The api version
     * @type {string}
     */
    static readonly API_VERSION: string;
    /**
     * Creates an instance of an Config.
     * @param {ConfigOptions} options The config options.
     * @return {Promise<Config>} An instance of Config.
     * @throws {SfdxError} **`{name: 'InvalidInstanceUrl'}`** Invalid instance URL.
     * @throws {SfdxError} **`{name: 'InvalidApiVersion'}`** Invalid API version.
     * @example
     * const config: Config = await Sfdx.create<Config>({ isGlobal: false }};
     * config.set(allowedPropertyKey, value);
     * await config.write();
     */
    static create<T extends ConfigFile>(options: ConfigOptions): Promise<T>;
    static getFileName(): string;
    /**
     * @returns {ConfigPropertyMeta[]} Returns an object representing the supported allowed properties.
     */
    static getAllowedProperties(): ConfigPropertyMeta[];
    /**
     * The value of a supported config property.
     * @param {boolean} isGlobal True for a global config. False for a local config.
     * @param {string} propertyName The name of the property to set.
     * @param {ConfigValue} [value] The property value.
     * @returns {Promise<object>}
     */
    static update(isGlobal: boolean, propertyName: string, value?: ConfigValue): Promise<object>;
    /**
     * Clear all the configured properties both local and global.
     * @returns {Promise<void>}
     */
    static clear(): Promise<void>;
    private static allowedProperties;
    private static messages;
    private static propertyConfigMap;
    private crypto?;
    /**
     * @returns {Promise<object>} Read, assign, and return the config contents.
     */
    read(): Promise<ConfigContents>;
    /**
     * Writes Config properties taking into account encrypted properties.
     * @param {ConfigContents} newContents The new Config value to persist.
     * @return {Promise<ConfigContents>}
     */
    write(newContents?: ConfigContents): Promise<ConfigContents>;
    /**
     * Sets a value for a property.
     * @param {string} propertyName The property to set.
     * @param {ConfigValue} value The value of the property.
     * @returns {Promise<void>}
     * @throws {SfdxError} **`{name: 'InvalidConfigValue'}`** Invalid configuration value.
     */
    set(key: string, value: ConfigValue): ConfigContents;
    /**
     * Initialize the crypto dependency.
     * @return {Promise<void>}
     */
    private initCrypto;
    /**
     * Closes the crypto dependency. Crypto should be close after it's used and no longer needed.
     * @return {Promise<void>}
     */
    private clearCrypto;
    /**
     * Get an individual property config.
     * @param {string} propertyName The name of the property.
     * @return {ConfigPropertyMeta} The meta config.
     */
    private getPropertyConfig;
    /**
     * Encrypts and content properties that have a encryption attribute.
     * @param {boolean} encrypt `true` to encrypt.
     * @return {Promise<void>}
     */
    private cryptProperties;
}
export declare const ORG_DEFAULT: {
    DEVHUB: string;
    USERNAME: string;
    list(): string[];
};
