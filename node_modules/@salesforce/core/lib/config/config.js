"use strict";
/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
/**
 * Contains meta information about sfdx config properties.
 * @typedef {object} ConfigPropertyMeta
 * @property {string} key The config property name.
 * @property {input} value Reference to the config data input validation.
 * @property {boolean} hidden True if the property should be indirectly hidden from the user.
 * @property {boolean} encrypted True if the property values should be stored encrypted.
 */
/**
 * Contains meta information about sfdx config properties.
 * @typedef {object} ConfigPropertyMetaInput
 * @property {function} validator Test if the input value is valid.
 * @property {string} failedMessage The message to return in the error if the validation fails.
 */
/**
 * Supported Org Default Types.
 * @typedef {object} ORG_DEFAULT
 * @property {string} DEVHUB Default developer hub username.
 * @property {string} USERNAME Default username.
 * @property {function} list `() => string[]` List the Org defaults.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const crypto_1 = require("../crypto");
const messages_1 = require("../messages");
const sfdxError_1 = require("../sfdxError");
const sfdc_1 = require("../util/sfdc");
const configFile_1 = require("./configFile");
const SFDX_CONFIG_FILE_NAME = 'sfdx-config.json';
/**
 * The files where sfdx config values are stored for projects and the global space.
 *
 * *Note:* It is not recommended to instantiate this object directly when resolving
 * config values. Instead use {@link ConfigAggregator}
 *
 * @extends ConfigFile
 *
 * @example
 * const localConfig = await Config.retrieve<Config>();
 * localConfig.set('defaultusername', 'username@company.org');
 * await localConfig.write();
 *
 * @see https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_cli_config_values.htm
 */
class Config extends configFile_1.ConfigFile {
    /**
     * Creates an instance of an Config.
     * @param {ConfigOptions} options The config options.
     * @return {Promise<Config>} An instance of Config.
     * @throws {SfdxError} **`{name: 'InvalidInstanceUrl'}`** Invalid instance URL.
     * @throws {SfdxError} **`{name: 'InvalidApiVersion'}`** Invalid API version.
     * @example
     * const config: Config = await Sfdx.create<Config>({ isGlobal: false }};
     * config.set(allowedPropertyKey, value);
     * await config.write();
     */
    static async create(options) {
        if (!Config.messages) {
            Config.messages = messages_1.Messages.loadMessages('@salesforce/core', 'config');
        }
        if (!Config.allowedProperties) {
            Config.allowedProperties = [
                {
                    key: 'instanceUrl',
                    input: {
                        // If a value is provided validate it otherwise no value is unset.
                        validator: value => value == null || (ts_types_1.isString(value) && sfdc_1.isSalesforceDomain(value)),
                        failedMessage: Config.messages.getMessage('InvalidInstanceUrl')
                    }
                },
                {
                    key: Config.API_VERSION,
                    hidden: true,
                    input: {
                        // If a value is provided validate it otherwise no value is unset.
                        validator: value => ts_types_1.isString(value) && sfdc_1.validateApiVersion(value),
                        failedMessage: Config.messages.getMessage('InvalidApiVersion')
                    }
                },
                { key: Config.DEFAULT_DEV_HUB_USERNAME },
                { key: Config.DEFAULT_USERNAME },
                { key: Config.ISV_DEBUGGER_SID, encrypted: true },
                { key: Config.ISV_DEBUGGER_URL },
                // This should be brought in by a plugin, but there isn't a way to do that right now.
                {
                    key: 'restDeploy',
                    hidden: true,
                    input: {
                        validator: value => value != null && ['true', 'false'].includes(value.toString()),
                        failedMessage: Config.messages.getMessage('InvalidBooleanConfigValue')
                    }
                },
                {
                    key: Config.USE_BACKUP_POLLING_ORG_CREATE,
                    input: {
                        validator: value => value == null || (value === 'true') || value === 'false',
                        failedMessage: `${Config.USE_BACKUP_POLLING_ORG_CREATE} must be a boolean value. true/false.`
                    }
                }
            ];
        }
        Config.propertyConfigMap = kit_1.keyBy(Config.allowedProperties, 'key');
        return await super.create(options);
    }
    static getFileName() {
        return SFDX_CONFIG_FILE_NAME;
    }
    /**
     * @returns {ConfigPropertyMeta[]} Returns an object representing the supported allowed properties.
     */
    static getAllowedProperties() {
        if (!Config.allowedProperties) {
            throw new sfdxError_1.SfdxError('Config meta information has not been initialized. Use Config.create()');
        }
        return Config.allowedProperties;
    }
    /**
     * The value of a supported config property.
     * @param {boolean} isGlobal True for a global config. False for a local config.
     * @param {string} propertyName The name of the property to set.
     * @param {ConfigValue} [value] The property value.
     * @returns {Promise<object>}
     */
    static async update(isGlobal, propertyName, value) {
        const config = await Config.create(Config.getDefaultOptions(isGlobal));
        const content = await config.read();
        if (value == null) {
            content.delete(propertyName);
        }
        else {
            content.set(propertyName, value);
        }
        return config.write(content);
    }
    /**
     * Clear all the configured properties both local and global.
     * @returns {Promise<void>}
     */
    static async clear() {
        let config = await Config.create(Config.getDefaultOptions(true));
        config.clear();
        await config.write();
        config = await Config.create(Config.getDefaultOptions(false));
        config.clear();
        await config.write();
    }
    /**
     * @returns {Promise<object>} Read, assign, and return the config contents.
     */
    async read() {
        try {
            await super.read();
            await this.cryptProperties(false);
            return this.getContents();
        }
        finally {
            await this.clearCrypto();
        }
    }
    /**
     * Writes Config properties taking into account encrypted properties.
     * @param {ConfigContents} newContents The new Config value to persist.
     * @return {Promise<ConfigContents>}
     */
    async write(newContents) {
        if (newContents != null) {
            this.setContents(newContents);
        }
        await this.cryptProperties(true);
        await super.write();
        await this.cryptProperties(false);
        return this.getContents();
    }
    /**
     * Sets a value for a property.
     * @param {string} propertyName The property to set.
     * @param {ConfigValue} value The value of the property.
     * @returns {Promise<void>}
     * @throws {SfdxError} **`{name: 'InvalidConfigValue'}`** Invalid configuration value.
     */
    set(key, value) {
        const property = Config.allowedProperties.find(allowedProp => allowedProp.key === key);
        if (!property) {
            throw sfdxError_1.SfdxError.create('@salesforce/core', 'config', 'UnknownConfigKey', [key]);
        }
        if (property.input) {
            if (property.input && property.input.validator(value)) {
                super.set(property.key, value);
            }
            else {
                throw sfdxError_1.SfdxError.create('@salesforce/core', 'config', 'InvalidConfigValue', [property.input.failedMessage]);
            }
        }
        else {
            super.set(property.key, value);
        }
        return this.getContents();
    }
    /**
     * Initialize the crypto dependency.
     * @return {Promise<void>}
     */
    async initCrypto() {
        if (!this.crypto) {
            this.crypto = await crypto_1.Crypto.create();
        }
    }
    /**
     * Closes the crypto dependency. Crypto should be close after it's used and no longer needed.
     * @return {Promise<void>}
     */
    async clearCrypto() {
        if (this.crypto) {
            this.crypto.close();
            delete this.crypto;
        }
    }
    /**
     * Get an individual property config.
     * @param {string} propertyName The name of the property.
     * @return {ConfigPropertyMeta} The meta config.
     */
    getPropertyConfig(propertyName) {
        const prop = Config.propertyConfigMap[propertyName];
        if (!prop) {
            throw sfdxError_1.SfdxError.create('@salesforce/core', 'config', 'UnknownConfigKey', [propertyName]);
        }
        return prop;
    }
    /**
     * Encrypts and content properties that have a encryption attribute.
     * @param {boolean} encrypt `true` to encrypt.
     * @return {Promise<void>}
     */
    async cryptProperties(encrypt) {
        const hasEncryptedProperties = this.entries().some(([key]) => {
            return !!ts_types_1.ensure(Config.propertyConfigMap[key]).encrypted;
        });
        if (hasEncryptedProperties) {
            await this.initCrypto();
            const crypto = ts_types_1.ensure(this.crypto);
            this.forEach((key, value) => {
                if (this.getPropertyConfig(key).encrypted && ts_types_1.isString(value)) {
                    this.set(key, ts_types_1.ensure(encrypt ? crypto.encrypt(value) : crypto.decrypt(value)));
                }
            });
        }
    }
}
/**
 * Username associated with the default dev hub org.
 * @type {string}
 */
Config.DEFAULT_DEV_HUB_USERNAME = 'defaultdevhubusername';
/**
 * Username associate with the default org.
 * @type {string}
 */
Config.DEFAULT_USERNAME = 'defaultusername';
/**
 * The sid for the debugger configuration.
 * @type {string}
 */
Config.ISV_DEBUGGER_SID = 'isvDebuggerSid';
/**
 * The url for the debugger configuration.
 * @type {string}
 */
Config.ISV_DEBUGGER_URL = 'isvDebuggerUrl';
/**
 * true if polling should be used over streaming when creating scratch orgs.
 * @type {string}
 */
Config.USE_BACKUP_POLLING_ORG_CREATE = 'useBackupPolling.org:create';
/**
 * The api version
 * @type {string}
 */
Config.API_VERSION = 'apiVersion';
exports.Config = Config;
exports.ORG_DEFAULT = {
    DEVHUB: Config.DEFAULT_DEV_HUB_USERNAME,
    USERNAME: Config.DEFAULT_USERNAME,
    list() {
        return [exports.ORG_DEFAULT.DEVHUB, exports.ORG_DEFAULT.USERNAME];
    }
};
//# sourceMappingURL=config.js.map