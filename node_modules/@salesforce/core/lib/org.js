"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Org Fields.
 * @typedef OrgFields
 * @property {string} ALIAS The org alias.
 * @property {string} CREATED_ORG_INSTANCE The Salesforce instance the org was created on. e.g. `cs42`.
 * @property {string} DEV_HUB_USERNAME The username of the dev hub org that created this org. Only populated for scratch orgs.
 * @property {string} INSTANCE_URL The full url of the instance the org lives on.
 * @property {string} IS_DEV_HUB Is the current org a dev hub org. e.g. They have access to the `ScratchOrgInfo` object.
 * @property {string} LOGIN_URL The login url of the org. e.g. `https://login.salesforce.com` or `https://test.salesforce.com`.
 * @property {string} ORG_ID The org ID.
 * @property {string} STATUS The `OrgStatus` of the org.
 * @property {string} SNAPSHOT The snapshot used to create the scratch org.
 */
/**
 * Scratch Org status.
 * @typedef OrgStatus
 * @property {string} ACTIVE The scratch org is active.
 * @property {string} EXPIRED The scratch org has expired.
 * @property {string} UNKNOWN The org is a scratch Org but no dev hub is indicated.
 * @property {string} MISSING The dev hub configuration is reporting an active Scratch org but the AuthInfo cannot be found.
 */
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const path_1 = require("path");
const authInfo_1 = require("./authInfo");
const aliases_1 = require("./config/aliases");
const config_1 = require("./config/config");
const configAggregator_1 = require("./config/configAggregator");
const orgUsersConfig_1 = require("./config/orgUsersConfig");
const connection_1 = require("./connection");
const global_1 = require("./global");
const logger_1 = require("./logger");
const sfdxError_1 = require("./sfdxError");
const fs = require("./util/fs");
const sfdc_1 = require("./util/sfdc");
var OrgStatus;
(function (OrgStatus) {
    OrgStatus["ACTIVE"] = "ACTIVE";
    OrgStatus["EXPIRED"] = "EXPIRED";
    OrgStatus["UNKNOWN"] = "UNKNOWN";
    OrgStatus["MISSING"] = "MISSING";
})(OrgStatus = exports.OrgStatus || (exports.OrgStatus = {}));
// A subset of fields from AuthInfoFields and properties that are specific to Org,
// and properties that are defined on Org itself.
var OrgFields;
(function (OrgFields) {
    // From AuthInfo
    OrgFields["ALIAS"] = "alias";
    OrgFields["CREATED"] = "created";
    OrgFields["CREATED_ORG_INSTANCE"] = "createdOrgInstance";
    OrgFields["DEV_HUB_USERNAME"] = "devHubUsername";
    OrgFields["INSTANCE_URL"] = "instanceUrl";
    OrgFields["IS_DEV_HUB"] = "isDevHub";
    OrgFields["LOGIN_URL"] = "loginUrl";
    OrgFields["ORG_ID"] = "orgId";
    // From Org
    OrgFields["STATUS"] = "status";
    OrgFields["SNAPSHOT"] = "snapshot";
    // Should it be on org? Leave it off for now, as it might
    // be confusing to the consumer what this actually is.
    // USERNAMES = 'usernames',
    // Keep separation of concerns. I think these should be on a "user" that belongs to the org.
    // Org can have a list of user objects that belong to it? Should connection be on user and org.getConnection()
    // gets the orgs current user for the process? Maybe we just want to keep with the Org only model for
    // the end of time?
    // USER_ID = 'userId',
    // USERNAME = 'username',
    // PASSWORD = 'password',
    // USER_PROFILE_NAME = 'userProfileName'
})(OrgFields = exports.OrgFields || (exports.OrgFields = {}));
/**
 * Provides a way to manage a locally authenticated Org.
 *
 * @see {@link AuthInfo}
 * @see {@link Connection}
 * @see {@link Aliases}
 * @see {@link Config}
 *
 * @example
 * // Email username
 * const org1: Org = await Org.create('foo@example.com');
 * // An alias
 * const org2: Org = await Org.create('fooAlias');
 * // The defaultusername config property
 * const org2: Org = await Org.create();
 * // Full Connection
 * const org3: Org = await Org.create(await Connection.create(await AuthInfo.create('bar@example.com')));
 *
 * @see https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_cli_usernames_orgs.htm
 */
class Org {
    /**
     * **Do not directly construct instances of this class -- use {@link Org.create} instead.**
     *
     * @private
     * @constructor
     */
    constructor(_aggregator) {
        // tslint:disable-next-line:no-unused-variable
        this.status = OrgStatus.UNKNOWN;
        this.configAggregator = _aggregator;
    }
    /**
     * Static initializer that allows creating an instance of an org from an alias, username, or Connection. If no identifier
     * is provided then the defaultusername is used. If isDevHub is true then the defaultdevhubusername is used.
     * @see {@link Config}
     * @param {string | Connection} [connection] The string alias or username.
     * @param {ConfigAggregator} [aggregator] optional config aggregator.
     * @param {boolean} [isDevHub] true if this org is a devhub. defaults to false.
     * @return {Promise<Org>}
     */
    static async create(connection, aggregator, isDevHub) {
        const _aggregator = aggregator ? aggregator : await configAggregator_1.ConfigAggregator.create();
        const org = new Org(_aggregator);
        org.logger = await logger_1.Logger.child('Org');
        let _connection;
        if (!connection) {
            org.logger.debug('No connection specified. Trying default configurations');
            connection = isDevHub ?
                ts_types_1.asString(kit_1.get(_aggregator.getInfo(config_1.Config.DEFAULT_DEV_HUB_USERNAME), 'value')) :
                ts_types_1.asString(kit_1.get(_aggregator.getInfo(config_1.Config.DEFAULT_USERNAME), 'value'));
            if (!connection) {
                throw new sfdxError_1.SfdxError(`No ${isDevHub ? 'default Devhub' : 'default'} username or Connection found.`, 'NoUsername');
            }
        }
        if (ts_types_1.isString(connection)) {
            org.logger.debug('connection type is string');
            const aliasValue = await aliases_1.Aliases.fetch(connection);
            _connection = await connection_1.Connection.create(await authInfo_1.AuthInfo.create(aliasValue || connection), _aggregator);
        }
        else {
            _connection = connection;
        }
        org.logger.debug(`connection created for org user: ${_connection.getUsername()}`);
        org.setConnection(_connection);
        return org;
    }
    /**
     * Clean all data files in the org's data path. Usually <workspace>/.sfdx/orgs/<username>.
     * @param {string} [orgDataPath] A relative path other than "orgs/".
     * @returns {Promise<void>}
     */
    async cleanLocalOrgData(orgDataPath, throwWhenRemoveFails = false) {
        let dataPath;
        try {
            const rootFolder = await config_1.Config.resolveRootFolder(false);
            dataPath = path_1.join(rootFolder, global_1.Global.STATE_FOLDER, orgDataPath ? orgDataPath : 'orgs');
            this.logger.debug(`cleaning data for path: ${dataPath}`);
        }
        catch (err) {
            if (err.name === 'InvalidProjectWorkspace') {
                // If we aren't in a project dir, we can't clean up data files.
                // If the user unlink this org outside of the workspace they used it in,
                // data files will be left over.
                return;
            }
            throw err;
        }
        return this.manageDelete(async () => await fs.remove(dataPath), dataPath, throwWhenRemoveFails);
    }
    async retrieveOrgUsersConfig() {
        return await orgUsersConfig_1.OrgUsersConfig.create(orgUsersConfig_1.OrgUsersConfig.getOptions(this.getOrgId()));
    }
    /**
     * Removes the scratch org config file at $HOME/.sfdx/[name].json, any project level org
     * files, all user auth files for the org, matching default config settings, and any
     * matching aliases.
     * @param {boolean} [throwWhenRemoveFails = false] Determines if the call should throw an error or fail silently.
     * @returns {Promise<void>}
     */
    async remove(throwWhenRemoveFails = false) {
        // If deleting via the access token there shouldn't be any auth config files
        // so just return;
        if (this.getConnection().isUsingAccessToken()) {
            return Promise.resolve();
        }
        const auths = await this.readUserAuthFiles();
        const aliases = await aliases_1.Aliases.retrieve();
        this.logger.info(`Cleaning up usernames in org: ${this.getOrgId()}`);
        for (const auth of auths) {
            const username = auth.getFields().username;
            const aliasKeys = (username && aliases.getKeysByValue(username)) || [];
            aliases.unsetAll(aliasKeys);
            let orgForUser;
            if (username === this.getUsername()) {
                orgForUser = this;
            }
            else {
                const _info = await authInfo_1.AuthInfo.create(username);
                const connection = await connection_1.Connection.create(_info);
                orgForUser = await Org.create(connection);
            }
            const orgType = await this.isDevHubOrg() ? config_1.Config.DEFAULT_DEV_HUB_USERNAME : config_1.Config.DEFAULT_USERNAME;
            const configInfo = await orgForUser.configAggregator.getInfo(orgType);
            if ((configInfo.value === username || aliasKeys.includes(configInfo.value)) &&
                (configInfo.isGlobal() || configInfo.isLocal())) {
                await config_1.Config.update(configInfo.isGlobal(), orgType, undefined);
            }
            const orgUsers = await this.retrieveOrgUsersConfig();
            await this.manageDelete(async () => await orgUsers.unlink(), orgUsers.getPath(), throwWhenRemoveFails);
        }
        await aliases.write();
    }
    /**
     * Check that this org is a scratch org by asking the dev hub if it knows about it.
     * @param {string} [devHubUsername] The username of the dev hub org.
     * @returns {Promise<Config>}
     * @throws {SfdxError} **`{name: 'NotADevHub'}`** Not a Dev Hub.
     * @throws {SfdxError} **`{name: 'NoResults'}`** No results.
     */
    async checkScratchOrg(devHubUsername) {
        let targetDevHub = devHubUsername;
        if (!targetDevHub) {
            targetDevHub = ts_types_1.asString(this.configAggregator.getPropertyValue(config_1.Config.DEFAULT_DEV_HUB_USERNAME));
        }
        const devHubConnection = await connection_1.Connection.create(await authInfo_1.AuthInfo.create(targetDevHub));
        const thisOrgAuthConfig = this.getConnection().getAuthInfoFields();
        const trimmedId = sfdc_1.trimTo15(thisOrgAuthConfig.orgId);
        const DEV_HUB_SOQL = `SELECT CreatedDate,Edition,ExpirationDate FROM ActiveScratchOrg WHERE ScratchOrg=\'${trimmedId}\'`;
        let results;
        try {
            results = await devHubConnection.query(DEV_HUB_SOQL);
        }
        catch (err) {
            if (err.name === 'INVALID_TYPE') {
                throw sfdxError_1.SfdxError.create('@salesforce/core', 'org', 'NotADevHub', [devHubConnection.getUsername()]);
            }
            throw err;
        }
        if (kit_1.get(results, 'records.length') !== 1) {
            throw new sfdxError_1.SfdxError('No results', 'NoResults');
        }
        return thisOrgAuthConfig;
    }
    /**
     * Returns the Org object or null if this org is not affiliated with a Dev Hub (according to the local config).
     * @returns {Promise<Org>}
     */
    async getDevHubOrg() {
        if (this.isDevHubOrg()) {
            return Promise.resolve(this);
        }
        else if (this.getField(OrgFields.DEV_HUB_USERNAME)) {
            return Org.create(await connection_1.Connection.create(await authInfo_1.AuthInfo.create(this.getField(OrgFields.DEV_HUB_USERNAME))));
        }
    }
    /**
     * Returns `true` if the org is a Dev Hub.
     * @returns {Boolean}
     */
    isDevHubOrg() {
        return this.getField(OrgFields.IS_DEV_HUB);
    }
    /**
     * Refreshes the auth for this org's instance by calling HTTP GET on the baseUrl of the connection object.
     * @returns {Promise<void>}
     */
    async refreshAuth() {
        this.logger.debug('Refreshing auth for org.');
        const requestInfo = {
            url: this.getConnection().baseUrl(),
            method: 'GET'
        };
        const conn = this.getConnection();
        await conn.request(requestInfo);
    }
    /**
     *  Reads and returns the content of all user auth files for this org as an array.
     *  @returns {Promise<AuthInfo[]>}
     */
    async readUserAuthFiles() {
        const config = await this.retrieveOrgUsersConfig();
        const contents = await config.read();
        const thisUsername = this.getUsername();
        const usernames = contents.get('usernames') || [thisUsername];
        return Promise.all(usernames.map(username => {
            if (username === thisUsername) {
                return authInfo_1.AuthInfo.create(this.getConnection().getUsername());
            }
            else {
                return authInfo_1.AuthInfo.create(username);
            }
        }));
    }
    /**
     * Adds a username to the user config for this org.
     * @param {AuthInfo | string} auth The AuthInfo for the username to add.
     * @returns {Promise<Org>} For convenience `this` object is returned.
     * @example
     * const org: Org = await Org.create(await Connection.create(await AuthInfo.create('foo@example.com')));
     * const userAuth: AuthInfo = await AuthInfo.create('bar@example.com');
     * await org.addUsername(userAuth);
     */
    async addUsername(auth) {
        if (!auth) {
            throw new sfdxError_1.SfdxError('Missing auth info', 'MissingAuthInfo');
        }
        const _auth = ts_types_1.isString(auth) ? await authInfo_1.AuthInfo.create(auth) : auth;
        this.logger.debug(`adding username ${_auth.getFields().username}`);
        const orgConfig = await this.retrieveOrgUsersConfig();
        const contents = await orgConfig.read();
        // TODO: This is kind of screwy because contents values can be `AnyJson | object`...
        // needs config refactoring to improve
        const usernames = ts_types_1.asJsonArray(ts_types_1.asAnyJson(contents.get('usernames'))) || [];
        if (!ts_types_1.isArray(usernames)) {
            throw new sfdxError_1.SfdxError('Usernames is not an array', 'UnexpectedDataFormat');
        }
        let shouldUpdate = false;
        const thisUsername = ts_types_1.ensure(this.getUsername());
        if (!usernames.includes(thisUsername)) {
            usernames.push(thisUsername);
            shouldUpdate = true;
        }
        const username = _auth.getFields().username;
        if (username) {
            usernames.push(username);
            shouldUpdate = true;
        }
        if (shouldUpdate) {
            orgConfig.set('usernames', usernames);
            await orgConfig.write();
        }
        return this;
    }
    /**
     * Removes a username from the user config for this object.
     * @param {AuthInfo | string} auth The AuthInfo containing the username to remove.
     * @returns {Promise<Org>} For convenience `this` object is returned.
     * @throws {SfdxError} **`{name: 'MissingAuthInfo'}`** Auth info is missing.
     */
    async removeUsername(auth) {
        if (!auth) {
            throw new sfdxError_1.SfdxError('Missing auth info', 'MissingAuthInfo');
        }
        const _auth = ts_types_1.isString(auth) ? await authInfo_1.AuthInfo.create(auth) : auth;
        this.logger.debug(`removing username ${_auth.getFields().username}`);
        const orgConfig = await this.retrieveOrgUsersConfig();
        const contents = await orgConfig.read();
        const targetUser = _auth.getFields().username;
        const usernames = (contents.get('usernames') || []);
        contents.set('usernames', usernames.filter(username => username !== targetUser));
        await orgConfig.write();
        return this;
    }
    /**
     * Retrieves the highest api version that is supported by the target server instance. If the apiVersion configured for
     * Sfdx is greater than the one returned in this call an api version mismatch occurs. In the case of the CLI that
     * results in a warning.
     * @returns {Promise<string>} The max api version number, i.e `46.0`.
     */
    async retrieveMaxApiVersion() {
        return await this.getConnection().retrieveMaxApiVersion();
    }
    /**
     * Returns the admin username used to create the org.
     * @return {Optional<string>}
     */
    getUsername() {
        return this.getConnection().getUsername();
    }
    /**
     * Returns the orgId for this org.
     * @return {string}
     */
    getOrgId() {
        return this.getField(OrgFields.ORG_ID);
    }
    /**
     * Returns for the config aggregator.
     * @returns {ConfigAggregator}
     */
    getConfigAggregator() {
        return this.configAggregator;
    }
    /**
     * Returns an org field. Returns undefined if the field is not set or invalid.
     * @returns {AnyJson}
     */
    getField(key) {
        // @ts-ignore TODO: Need to refactor storage of these values on both Org and AuthFields
        return this[key] || this.getConnection().getAuthInfoFields()[key];
    }
    /**
     * Returns a map of requested fields.
     * @returns {Dictionary<AnyJson>}
     */
    getFields(keys) {
        return keys.reduce((map, key) => {
            map[key] = this.getField(key);
            return map;
        }, {});
    }
    /**
     * Returns the JSForce connection for the org.
     * @returns {Connection}
     */
    getConnection() {
        return this.connection;
    }
    /**
     * Sets the JSForce connection to use for this org.
     * @param {Connection} connection The connection to use.
     * @returns {Org} For convenience `this` object is returned.
     * @throws {SfdxError} **`{name: 'UndefinedConnection'}`** The connection was not defined.
     * @see {@link http://jsforce.github.io/jsforce/doc/Connection.html}
     */
    setConnection(connection) {
        if (connection) {
            this.connection = connection;
            return this;
        }
        else {
            throw new sfdxError_1.SfdxError('Connection not specified', 'UndefinedConnection');
        }
    }
    manageDelete(cb, dirPath, throwWhenRemoveFails) {
        return cb().catch(e => {
            if (throwWhenRemoveFails) {
                throw e;
            }
            else {
                this.logger.warn(`failed to read directory ${dirPath}`);
                return;
            }
        });
    }
}
exports.Org = Org;
//# sourceMappingURL=org.js.map