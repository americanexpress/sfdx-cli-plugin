/**
 * Options for OAuth2.
 * @typedef OAuth2Options
 * @property {string} authzServiceUrl
 * @property {string} tokenServiceUrl
 * @property {string} clientId
 * @property {string} clientSecret
 * @property {string} httpProxy
 * @property {string} loginUrl
 * @property {string} proxyUrl
 * @property {string} redirectUri
 * @property {string} refreshToken
 * @property {string} revokeServiceUrl
 * @property {string} authCode
 * @property {string} privateKeyFile
 * @see https://jsforce.github.io/jsforce/doc/OAuth2.html
 */
import { Nullable, Optional } from '@salesforce/ts-types';
import { OAuth2Options } from 'jsforce';
import { Connection } from './connection';
export interface AuthFields {
    accessToken?: string;
    alias?: string;
    authCode?: string;
    clientId?: string;
    clientSecret?: string;
    created?: string;
    createdOrgInstance?: string;
    devHubUsername?: string;
    instanceUrl?: string;
    isDevHub?: boolean;
    loginUrl?: string;
    orgId?: string;
    password?: string;
    privateKey?: string;
    refreshToken?: string;
    scratchAdminUsername?: string;
    snapshot?: string;
    userId?: string;
    username?: string;
    usernames?: string[];
    userProfileName?: string;
}
export interface AccessTokenOptions {
    accessToken?: string;
    loginUrl?: string;
    instanceUrl?: string;
}
export declare type RefreshFn = (conn: Connection, callback: (err: Nullable<Error>, accessToken?: string, res?: object) => Promise<void>) => Promise<void>;
export declare type ConnectionOptions = AuthFields & {
    oauth2?: Partial<OAuth2Options>;
    refreshFn?: RefreshFn;
};
export declare enum SFDC_URLS {
    sandbox = "https://test.salesforce.com",
    production = "https://login.salesforce.com"
}
/**
 * Handles persistence and fetching of user authentication information using
 * JWT, OAuth, or refresh tokens. Sets up the refresh flows that jsForce will
 * use to keep tokens active. An AuthInfo can also be created with an access
 * token, but AuthInfos created with access tokens can't be persisted to disk.
 *
 * @example
 * // Creating a new authentication file.
 * const authInfo = await AuthInfo.create(myAdminUsername, {
 *     loginUrl, authCode, clientId, clientSecret
 * });
 * authInfo.save();
 *
 * // Creating an authorization info with an access token.
 * const authInfo = await AuthInfo.create(accessToken);
 *
 * // Using an existing authentication file.
 * const authInfo = await AuthInfo.create(myAdminUsername);
 *
 * // Using the AuthInfo
 * const connection = await Connection.create(authInfo);
 *
 * @see https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth.htm
 * @see https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_cli_usernames_orgs.htm
 */
export declare class AuthInfo {
    /**
     * Create an instance of AuthInfo for the provided username and options.
     * If options are not provided, attempt to read the authorization information from disk.
     *
     * @param {string} [username] The username for the authentication info.
     * @param {OAuth2Options} [options] Options to be used for creating an OAuth2 instance.
     * @throws {SfdxError}
     *    **`{name: 'NamedOrgNotFound'}`:** Org information does not exist.
     * @throws {SfdxError}
     *    **`{name: 'AuthInfoCreationError'}`:** Org information does not exist.
     * @returns {Promise<AuthInfo>}
     */
    static create(username?: string, options?: OAuth2Options | AccessTokenOptions): Promise<AuthInfo>;
    /**
     * Get a list of all auth files stored in the global directory.
     * @returns {Promise<string[]>}
     */
    static listAllAuthFiles(): Promise<string[]>;
    /**
     * Returns true if one or more authentications are persisted.
     * @returns {Promise<boolean>}
     */
    static hasAuthentications(): Promise<boolean>;
    /**
     * Get the authorization URL.
     * @param {OAuth2Options} options The options to generate the URL.
     * @returns {string}
     */
    static getAuthorizationUrl(options: OAuth2Options): string;
    /**
     * Forces the auth file to be re-read from disk for a given user.
     * @param {string} username The username for the auth info to re-read.
     * @returns {boolean} True if a value was removed.
     */
    static clearCache(username: string): boolean;
    private static authFilenameFilterRegEx;
    private static cache;
    private fields;
    private usingAccessToken;
    private logger;
    /**
     * **Do not directly construct instances of this class -- use {@link AuthInfo.create} instead.**
     *
     * @private
     * @constructor
     */
    private constructor();
    /**
     * Initialize an AuthInfo instance with the options. If options are not provided
     * initialize from cache or by reading from persistence store.
     * @param {OAuth2Options} [options] Options to be used for creating an OAuth2 instance.
     * @throws {SfdxError}
     *    **`{name: 'NamedOrgNotFound'}`:** Org information does not exist.
     * @returns {Promise<AuthInfo>} For convenience `this` object is returned.
     */
    init(options?: OAuth2Options | AccessTokenOptions): Promise<AuthInfo>;
    /**
     * Get the username.
     * @returns {string}
     */
    getUsername(): Optional<string>;
    /**
     * Returns true if `this` is using the JWT flow.
     * @returns {boolean}
     */
    isJwt(): boolean;
    /**
     * Returns true if `this` is using an access token flow.
     * @returns {boolean}
     */
    isAccessTokenFlow(): boolean;
    /**
     * Returns true if `this` is using the oauth flow.
     * @returns {boolean}
     */
    isOauth(): boolean;
    /**
     * Returns true if `this` is using the refresh token flow.
     * @returns {boolean}
     */
    isRefreshTokenFlow(): boolean;
    /**
     * Updates the cache and persists the authentication fields (encrypted).
     * @param {AuthFields} [authData] New data to save.
     * @returns {Promise<AuthInfo>}
     */
    save(authData?: AuthFields): Promise<AuthInfo>;
    /**
     * Update the authorization fields, encrypting sensitive fields, but do not persist.
     *
     * @param {AuthFields} authData Authorization fields to update.
     * @param {boolean} encrypt Encrypt the fields.
     * @returns {AuthInfo} For convenience `this` object is returned.
     */
    update(authData?: AuthFields, encrypt?: boolean): AuthInfo;
    /**
     * Get the auth fields (decrypted) needed to make a connection.
     *
     * @returns {AuthFields}
     */
    getConnectionOptions(): ConnectionOptions;
    /**
     * Get the authorization fields.
     * @returns {AuthFields}
     */
    getFields(): AuthFields;
    /**
     * Returns true if this org is using access token auth.
     * @returns {boolean}
     */
    isUsingAccessToken(): boolean;
    /**
     * Get the SFDX Auth URL.
     * @see https://developer.salesforce.com/docs/atlas.en-us.sfdx_cli_reference.meta/sfdx_cli_reference/cli_reference_force_auth.htm#cli_reference_force_auth
     * @returns {string}
     */
    getSfdxAuthUrl(): string;
    private isTokenOptions;
    private refreshFn;
    private buildJwtConfig;
    private buildRefreshTokenConfig;
    private buildWebAuthConfig;
    private lookup;
}
