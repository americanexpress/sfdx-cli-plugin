"use strict";
/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const kit_1 = require("@salesforce/kit");
const os_1 = require("os");
const logger_1 = require("./logger");
const messages_1 = require("./messages");
const sfdxError_1 = require("./sfdxError");
/**
 * A class for assigning a Salesforce User to one or more permission sets.
 */
class PermissionSetAssignment {
    /**
     * Creates a new instance of PermissionSetAssignment
     * @param org {PermissionSetAssignment} new instance of PermissionSetAssignment
     */
    static async init(org) {
        if (!org) {
            throw sfdxError_1.SfdxError.create('@salesforce/core', 'permissionSetAssignment', 'orgRequired');
        }
        return new PermissionSetAssignment(org, await logger_1.Logger.child('PermissionSetAssignment'));
    }
    /**
     * constructor
     * @param org {Org} The org containing the user and permission set.
     * @param logger {Logger} A Logger instance.
     */
    constructor(org, logger) {
        this.logger = logger;
        this.org = org;
    }
    /**
     * Assigns a user to one or more permission sets.
     * @param id {string} A user id
     * @param permSetString {string[]} An array of permission set names.
     */
    async create(id, permSetString) {
        if (!id) {
            throw sfdxError_1.SfdxError.create('@salesforce/core', 'permissionSetAssignment', 'userIdRequired');
        }
        if (!permSetString) {
            throw sfdxError_1.SfdxError.create('@salesforce/core', 'permissionSetAssignment', 'permSetRequired');
        }
        const { nsPrefix, permSetName } = this.parsePermissionSetString(permSetString);
        let query = `SELECT Id FROM PermissionSet WHERE Name='${permSetName}'`;
        if (nsPrefix) {
            query += ` AND NamespacePrefix='${nsPrefix}'`;
        }
        const result = await this.org.getConnection().query(query);
        const permissionSetId = kit_1.get(result, 'records[0].Id');
        if (!permissionSetId) {
            if (nsPrefix) {
                throw sfdxError_1.SfdxError.create('@salesforce/core', 'permissionSetAssignment', 'assignCommandPermissionSetNotFoundForNSError', [permSetName, nsPrefix]);
            }
            else {
                throw sfdxError_1.SfdxError.create('@salesforce/core', 'permissionSetAssignment', 'assignCommandPermissionSetNotFoundError', [permSetName]);
            }
        }
        const assignment = {
            assigneeId: id,
            permissionSetId
        };
        let createResponse;
        createResponse = await this.org.getConnection().sobject('PermissionSetAssignment')
            .create(kit_1.mapKeys(assignment, (value, key) => kit_1.upperFirst(key)));
        if (createResponse.length) {
            throw sfdxError_1.SfdxError.create('@salesforce/core', 'permissionSetAssignment', 'unexpectedType');
        }
        else {
            if (createResponse.success) {
                return assignment;
            }
            else {
                const messages = messages_1.Messages.loadMessages('@salesforce/core', 'permissionSetAssignment');
                let message = messages.getMessage('errorsEncounteredCreatingAssignment');
                const errors = createResponse.errors;
                if (errors && errors.length > 0) {
                    message = `${message}:${os_1.EOL}`;
                    errors.forEach(_message => {
                        message = `${message}${_message}${os_1.EOL}`;
                    });
                    throw new sfdxError_1.SfdxError(message, 'errorsEncounteredCreatingAssignment');
                }
                else {
                    throw sfdxError_1.SfdxError.create('@salesforce/core', 'permissionSetAssignment', 'notSuccessfulButNoErrorsReported');
                }
            }
        }
    }
    /**
     * Parses a permission set name based on if it has a namespace or not.
     * @param permSetString {string} The permission set string.
     */
    parsePermissionSetString(permSetString) {
        const nsPrefixMatch = permSetString.match(/(\w+(?=__))(__)(.*)/);
        let nsPrefix;
        let permSetName;
        if (nsPrefixMatch) {
            try {
                nsPrefix = nsPrefixMatch[1];
                permSetName = nsPrefixMatch[3];
                this.logger.debug(`Using namespacePrefix ${nsPrefix} for permission set ${permSetName}`);
            }
            catch (e) {
                // Don't fail if we parse wrong.
                this.logger.debug(e);
            }
        }
        else {
            permSetName = permSetString;
        }
        return { nsPrefix, permSetName };
    }
}
exports.PermissionSetAssignment = PermissionSetAssignment;
//# sourceMappingURL=permissionSetAssignment.js.map