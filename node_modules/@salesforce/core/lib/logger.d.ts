/// <reference types="node" />
import { Writable } from 'stream';
export declare type Serializer = (input: any) => any;
export interface Serializers {
    [key: string]: Serializer;
}
export interface LoggerOptions {
    name: string;
    serializers?: Serializers;
    src?: boolean;
    level?: LoggerLevelValue;
    stream?: Writable;
    streams?: LoggerStream[];
}
export declare enum LoggerLevel {
    TRACE = 10,
    DEBUG = 20,
    INFO = 30,
    WARN = 40,
    ERROR = 50,
    FATAL = 60
}
export interface LoggerStream {
    type?: string;
    level?: LoggerLevelValue;
    stream?: Writable;
    name?: string;
    path?: string;
    [key: string]: any;
}
export declare type LoggerLevelValue = LoggerLevel | number;
export interface Fields {
    [key: string]: FieldValue;
}
export declare type FieldValue = string | number | boolean;
/**
 * A logging abstraction powered by {@link https://github.com/cwallsfdc/node-bunyan|Bunyan} that provides both a default
 * logger configuration that will log to `sfdx.log`, and a way to create custom loggers based on the same foundation.
 *
 * @example
 * // Gets the root sfdx logger
 * const logger = await Logger.root();
 * @example
 * // Creates a child logger of the root sfdx logger with custom fields applied
 * const childLogger = await Logger.child('myRootChild', {tag: 'value'});
 * @example
 * // Creates a custom logger unaffiliated with the root logger
 * const myCustomLogger = new Logger('myCustomLogger');
 * @example
 * // Creates a child of a custom logger unaffiliated with the root logger with custom fields applied
 * const myCustomChildLogger = myCustomLogger.child('myCustomChild', {tag: 'value'});
 *
 * @see https://github.com/cwallsfdc/node-bunyan
 * @see https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_cli_log_messages.htm
 */
export declare class Logger {
    /**
     * The name of the root sfdx `Logger`.
     *
     * @type {string}
     * @see Logger.root
     */
    static readonly ROOT_NAME: string;
    /**
     * The default `LoggerLevel` when constructing new `Logger` instances.
     *
     * @type {LoggerLevel}
     */
    static readonly DEFAULT_LEVEL: LoggerLevel;
    /**
     * A list of all lower case `LoggerLevel` names.
     *
     * @type {string[]}
     * @see LoggerLevel
     */
    static readonly LEVEL_NAMES: any[];
    /**
     * Gets the root logger with the default level and file stream.
     *
     * @returns {Promise<Logger>}
     */
    static root(): Promise<Logger>;
    /**
     * Destroys the root `Logger`.
     *
     * @ignore
     */
    static destroyRoot(): void;
    /**
     * Create a child of the root logger, inheriting this instance's configuration such as `level`, `streams`, etc.
     *
     * @param {string} name The name of the child logger.
     * @param {Fields} [fields] Additional fields included in all log lines.
     * @returns {Promise<Logger>}
     */
    static child(name: string, fields?: Fields): Promise<Logger>;
    /**
     * Gets a numeric `LoggerLevel` value by string name.
     *
     * @param {string} levelName The level name to convert to a `LoggerLevel` enum value.
     * @throws {SfdxError}
     *    **`{name: 'UnrecognizedLoggerLevelName'}`:** The level name was not case-insensitively recognized as a valid `LoggerLevel` value.
     * @see LoggerLevel
     */
    static getLevelByName(levelName: string): LoggerLevelValue;
    private static readonly lifecycle;
    private static rootLogger?;
    private bunyan;
    /**
     * Constructs a new `Logger`.
     *
     * @param {LoggerOptions|string} optionsOrName A set of `LoggerOptions` or name to use with the default options.
     * @throws {SfdxError}
     *    **`{name: 'RedundantRootLogger'}`:** More than one attempt is made to construct the root `Logger`.
     */
    constructor(optionsOrName: LoggerOptions | string);
    /**
     * Adds a stream.
     *
     * @param {LoggerStream} stream The stream configuration to add.
     * @param {LoggerLevelValue} [defaultLevel] The default level of the stream.
     */
    addStream(stream: LoggerStream, defaultLevel?: LoggerLevelValue): void;
    /**
     * Adds a file stream to this logger.
     *
     * @param {string} logFile The path to the log file.  If it doesn't exist it will be created.
     * @returns {Promise<void>} Resolved or rejected upon completion of the addition.
     */
    addLogFileStream(logFile: string): Promise<void>;
    /**
     * Gets the name of this logger.
     *
     * @returns {string}
     */
    getName(): string;
    /**
     * Gets the current level of this logger.
     *
     * @returns {LoggerLevelValue}
     */
    getLevel(): LoggerLevelValue;
    /**
     * Set the logging level of all streams for this logger.  If a specific `level` is not provided, this method will
     * attempt to read it from the environment variable `SFDX_LOG_LEVEL`, and if not found,
     * {@link Logger.DEFAULT_LOG_LEVEL} will be used instead.
     *
     * @example
     * // Sets the level from the environment or default value
     * logger.setLevel()
     * @example
     * // Set the level from the INFO enum
     * logger.setLevel(LoggerLevel.INFO)
     * @example
     * // Sets the level case-insensitively from a string value
     * logger.setLevel(Logger.getLevelByName('info'))
     *
     * @param {LoggerLevelValue} [level] The logger level.
     * @returns {Logger} For convenience `this` object is returned.
     * @throws {SfdxError}
     *    **`{name: 'UnrecognizedLoggerLevelName'}`:** A value of `level` read from `SFDX_LOG_LEVEL` was invalid.
     */
    setLevel(level?: LoggerLevelValue): Logger;
    /**
     * Gets the underlying Bunyan logger.
     *
     * @returns {any} The low-level Bunyan logger.
     */
    getBunyanLogger(): any;
    /**
     * Compares the requested log level with the current log level.  Returns true if
     * the requested log level is greater than or equal to the current log level.
     *
     * @param {LoggerLevelValue} level The requested log level to compare against the currently set log level.
     * @returns {boolean}
     */
    shouldLog(level: LoggerLevelValue): boolean;
    /**
     * Use in-memory logging for this logger instance instead of any parent streams. Useful for testing.
     *
     * **WARNING: This cannot be undone for this logger instance.**
     *
     * @returns {Logger} For convenience this object is returned.
     */
    useMemoryLogging(): Logger;
    /**
     * Gets an array of log line objects. Each element is an object that corresponds to a log line.
     *
     * @returns {Array<string>}
     */
    getBufferedRecords(): string[];
    /**
     * Reads a text blob of all the log lines contained in memory or the log file.
     *
     * @returns {string}
     */
    readLogContentsAsText(): string;
    /**
     * Adds a filter to be applied to all logged messages.
     *
     * @param {function} filter A function with signature `(...args: any[]) => any[]` that transforms log message arguments.
     */
    addFilter(filter: (...args: any[]) => any[]): void;
    /**
     * Close the logger, including any streams, and remove all listeners.
     *
     * @param {function} [fn] A function with signature `(stream: LoggerStream) => void` to call for each stream with
     *                        the stream as an arg.
     */
    close(fn?: (stream: LoggerStream) => void): void;
    /**
     * Create a child logger, typically to add a few log record fields.
     *
     * @param {string} name The name of the child logger that is emitted w/ log line as `log:<name>`.
     * @param {Fields} [fields] Additional fields included in all log lines for the child logger.
     * @returns {Logger} For convenience this object is returned.
     */
    child(name: string, fields?: Fields): Logger;
    /**
     * Add a field to all log lines for this logger.
     *
     * @param {string} name The name of the field to add.
     * @param {FieldValue} value The value of the field to be logged.
     * @returns {Logger} For convenience `this` object is returned.
     */
    addField(name: string, value: FieldValue): Logger;
    /**
     * Logs at `trace` level with filtering applied.
     *
     * @param {...any} args Any number of arguments to be logged.
     * @returns {Logger} For convenience `this` object is returned.
     */
    trace(...args: any[]): Logger;
    /**
     * Logs at `debug` level with filtering applied.
     *
     * @param {...any} args Any number of arguments to be logged.
     * @returns {Logger} For convenience `this` object is returned.
     */
    debug(...args: any[]): Logger;
    /**
     * Logs at `info` level with filtering applied.
     *
     * @param {...any} args Any number of arguments to be logged.
     * @returns {Logger} For convenience `this` object is returned.
     */
    info(...args: any[]): Logger;
    /**
     * Logs at `warn` level with filtering applied.
     *
     * @param {...any} args Any number of arguments to be logged.
     * @returns {Logger} For convenience `this` object is returned.
     */
    warn(...args: any[]): Logger;
    /**
     * Logs at `error` level with filtering applied.
     *
     * @param {...any} args Any number of arguments to be logged.
     * @returns {Logger} For convenience `this` object is returned.
     */
    error(...args: any[]): Logger;
    /**
     * Logs at `fatal` level with filtering applied.
     *
     * @param {...any} args Any number of arguments to be logged.
     * @returns {Logger} For convenience `this` object is returned.
     */
    fatal(...args: any[]): Logger;
    private applyFilters;
    private uncaughtExceptionHandler;
    private exitHandler;
}
