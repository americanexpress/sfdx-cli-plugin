/// <reference types="node" />
import { AnyJson, JsonMap, Optional } from '@salesforce/ts-types';
import { EventEmitter } from 'events';
import { ConfigContents } from './config/configStore';
import { Logger } from './logger';
import { SfdxError } from './sfdxError';
import { CometClient, CometSubscription } from './status/streamingClient';
/**
 * Different parts of the system that are mocked out. They can be restored for
 * individual tests. Test's stubs should always go on the DEFAULT which is exposed
 * on the TestContext.
 */
export interface SandboxTypes {
    DEFAULT: any;
    CRYPTO: any;
    CONFIG: any;
    CONNECTION: any;
}
export interface ConfigStub {
    readFn?: () => Promise<ConfigContents>;
    writeFn?: () => Promise<void>;
    contents?: JsonMap;
    retrieveContents?: () => Promise<JsonMap>;
    updateContents?: () => Promise<JsonMap>;
}
/**
 * Different configuration options when running before each
 */
export interface TestContext {
    SANDBOX: any;
    SANDBOXES: SandboxTypes;
    TEST_LOGGER: Logger;
    id: string;
    uniqid: () => string;
    configStubs: {
        [configName: string]: Optional<ConfigStub>;
        AuthInfoConfig?: ConfigStub;
        Aliases?: ConfigStub;
        SfdxProjectJson?: ConfigStub;
        SfdxConfig?: ConfigStub;
    };
    localPathRetriever: (uid: string) => Promise<string>;
    globalPathRetriever: (uid: string) => Promise<string>;
    rootPathRetriever: (isGlobal: boolean, uid?: string) => Promise<string>;
    fakeConnectionRequest: (request: AnyJson, options?: AnyJson) => Promise<AnyJson>;
}
/**
 * @module testSetup
 */
/**
 * Different hooks into {@link ConfigFile} used for testing instead of doing file IO.
 * @typedef {object} TestContext
 * @property {function} readFn A function `() => Promise<ConfigContents>;` that controls
 * all aspect of {@link ConfigFile.read}. For example, it won't set the contents unless
 * explicitly done. Only use this if you know what you are doing. Use retrieveContents
 * instead.
 * @property {function} writeFn A function `() => Promise<void>;` that controls all aspects
 * of {@link ConfigFile.write}. For example, it won't read the contents unless explicitly
 * done. Only use this if you know what you are doing. Use updateContents instead.
 * @property {object} contents The contents that are used when @{link ConfigFile.read} unless
 * retrieveContents is set. This will also contain the new config when @{link ConfigFile.write}
 * is called. This will persist through config instances, such as {@link Alias.update} and
 * {@link Alias.fetch}.
 * @property {function} retrieveContents A function `() => Promise<object>;` to conditionally
 * read based on the config instance. The `this` value will be the config instance.
 * @property {function} updateContents A function `() => Promise<object>;` to conditionally
 * set based on the config instance. The `this` value will be the config instance.
 */
/**
 * Different configuration options when running before each.
 * @typedef {object} TestContext
 * @property {sinon.sandbox} SANDBOX The default sandbox is cleared out before
 * each test run. See [sinon sandbox]{@link http://sinonjs.org/releases/v1.17.7/sandbox/}.
 * @property {SandboxTypes} SANDBOXES An object of different sandboxes. Used when
 * needing to restore parts of the system for customized testing.
 * @property {Logger} TEST_LOGGER The test logger that is used when {@link Logger.child}
 * is used anywhere. It uses memory logging.
 * @property {string} id A unique id for the test run.
 * @property {function} uniqid A function `() => string` that returns unique strings.
 * @property {object} configStubs An object of `[configName: string]: ConfigStub` used in test that interact with config files.
 * names to {@link ConfigStubs} that contain properties used when reading and writing
 * to config files.
 * @property {function} localPathRetriever A function `(uid: string) => Promise<string>;`
 * used when resolving the local path.
 * @property {function} globalPathRetriever A function `(uid: string) => Promise<string>;`
 * used when resolving the global path.
 * @property {function} rootPathRetriever: A function `(isGlobal: boolean, uid?: string) => Promise<string>;`
 * used then resolving paths. Calls localPathRetriever and globalPathRetriever.
 */
/**
 * Use to mock out different pieces of sfdx-core to make testing easier. This will mock out
 * logging to a file, config file reading and writing, local and global path resolution, and
 * *http request using connection (soon)*.
 * @function testSetup
 * @returns {TestContext}
 *
 * @example
 * // In a mocha tests
 * import testSetup from '@salesforce/core/lib/testSetup';
 *
 * const $$ = testSetup();
 *
 * describe(() => {
 *  it('test', () => {
 *    // Stub out your own method
 *    $$.SANDBOX.stub(MyClass.prototype, 'myMethod').returnsFake(() => {});
 *
 *    // Set the contents that is used when aliases are read. Same for all config files.
 *    $$.configStubs.Aliases = { contents: { 'myTestAlias': 'user@company.com' } };
 *
 *    // Will use the contents set above.
 *    const username = Aliases.fetch('myTestAlias');
 *    expect(username).to.equal('user@company.com');
 *  });
 * });
 */
export declare const testSetup: (sinon?: any) => TestContext;
/**
 * A pre-canned error for try/catch testing.
 * @see shouldThrow
 * @type {SfdxError}
 */
export declare const unexpectedResult: SfdxError;
/**
 * Use for this testing pattern:
 *
 *  try {
 *      await call()
 *      assert.fail('this should never happen');
 *  } catch (e) {
 *  ...
 *  }
 *
 *  Just do this
 *
 *  try {
 *      await shouldThrow(call()); // If this succeeds unexpectedResultError is thrown.
 *  } catch(e) {
 *  ...
 *  }
 *
 * @param {Promise<AnyJson>} f The async function that is expected to throw.
 * @returns {Promise<void>}
 */
export declare function shouldThrow(f: Promise<any>): Promise<never>;
/**
 * A helper to determine if a subscription will use callback or errorback.
 * Enable errback to simulate a subscription failure.
 */
export declare enum StreamingMockSubscriptionCall {
    CALLBACK = 0,
    ERRORBACK = 1
}
/**
 * Additional subscription options for the StreamingMock.
 */
export interface StreamingMockCometSubscriptionOptions {
    url: string;
    id: string;
    subscriptionCall: StreamingMockSubscriptionCall;
    subscriptionErrbackError?: SfdxError;
    messagePlaylist?: JsonMap[];
}
/**
 * Simulates a comet subscription to a streaming channel.
 */
export declare class StreamingMockCometSubscription extends EventEmitter implements CometSubscription {
    static SUBSCRIPTION_COMPLETE: string;
    static SUBSCRIPTION_FAILED: string;
    private options;
    constructor(options: StreamingMockCometSubscriptionOptions);
    callback(callback: () => void): void;
    errback(callback: (error: Error) => void): void;
}
/**
 * Simulates a comet client. To the core streaming client this mocks the internal comet impl.
 * The uses setTimeout(0ms) event loop phase just so the client can simulate actual streaming without the response
 * latency.
 */
export declare class StreamingMockCometClient extends CometClient {
    private readonly options;
    /**
     * Constructor
     * @param {StreamingMockCometSubscriptionOptions} options Extends the StreamingClient options.
     */
    constructor(options: StreamingMockCometSubscriptionOptions);
    addExtension(extension: JsonMap): void;
    disable(label: string): void;
    handshake(callback: () => void): void;
    setHeader(name: string, value: string): void;
    subscribe(channel: string, callback: (message: JsonMap) => void): CometSubscription;
    disconnect(): Promise<void>;
}
/**
 * Mock class for OrgData.
 */
export declare class MockTestOrgData {
    testId: string;
    alias?: string;
    username: string;
    devHubUsername?: string;
    orgId: string;
    loginUrl: string;
    instanceUrl: string;
    clientId: string;
    clientSecret: string;
    authcode: string;
    accessToken: string;
    refreshToken: string;
    userId: string;
    constructor(id?: string);
    createDevHubUsername(username: string): void;
    makeDevHub(): void;
    createUser(user: string): MockTestOrgData;
    getMockUserInfo(): JsonMap;
    getConfig(): Promise<ConfigContents>;
}
