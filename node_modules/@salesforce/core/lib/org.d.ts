import { AnyJson, Dictionary, Optional } from '@salesforce/ts-types';
import { AuthFields, AuthInfo } from './authInfo';
import { ConfigAggregator } from './config/configAggregator';
import { OrgUsersConfig } from './config/orgUsersConfig';
import { Connection } from './connection';
export declare enum OrgStatus {
    ACTIVE = "ACTIVE",
    EXPIRED = "EXPIRED",
    UNKNOWN = "UNKNOWN",
    MISSING = "MISSING"
}
export declare enum OrgFields {
    ALIAS = "alias",
    CREATED = "created",
    CREATED_ORG_INSTANCE = "createdOrgInstance",
    DEV_HUB_USERNAME = "devHubUsername",
    INSTANCE_URL = "instanceUrl",
    IS_DEV_HUB = "isDevHub",
    LOGIN_URL = "loginUrl",
    ORG_ID = "orgId",
    STATUS = "status",
    SNAPSHOT = "snapshot"
}
/**
 * Provides a way to manage a locally authenticated Org.
 *
 * @see {@link AuthInfo}
 * @see {@link Connection}
 * @see {@link Aliases}
 * @see {@link Config}
 *
 * @example
 * // Email username
 * const org1: Org = await Org.create('foo@example.com');
 * // An alias
 * const org2: Org = await Org.create('fooAlias');
 * // The defaultusername config property
 * const org2: Org = await Org.create();
 * // Full Connection
 * const org3: Org = await Org.create(await Connection.create(await AuthInfo.create('bar@example.com')));
 *
 * @see https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_cli_usernames_orgs.htm
 */
export declare class Org {
    /**
     * Static initializer that allows creating an instance of an org from a alias or a plain string username. If no
     * username or alias is provided then the defaultusername is used. If isDevHub is true then the defaultdevhub is used.
     * @param {string} [aliasOrUsername] The string alias or username.
     * @param {ConfigAggregator} [aggregator] optional config aggregator.
     * @param {boolean} [isDevHub] true if this org is a devhub. defaults to false.
     * @return {Promise<Org>}
     */
    static create(aliasOrUsername?: string, aggregator?: ConfigAggregator, isDevHub?: boolean): Promise<Org>;
    /**
     * Static initializer that allows creating an instance of an org from a Connection object.
     * @param {Connection} [connection] The connection
     * @param {ConfigAggregator} [aggregator] A config aggregator. (Optional)
     * @param {boolean} [isDevHub] True if this org is a devhub. defaults to false (Optional)
     * @return {Promise<Org>}
     */
    static create(connection?: Connection, aggregator?: ConfigAggregator, isDevHub?: boolean): Promise<Org>;
    private status;
    private configAggregator;
    private logger;
    private connection;
    /**
     * **Do not directly construct instances of this class -- use {@link Org.create} instead.**
     *
     * @private
     * @constructor
     */
    private constructor();
    /**
     * Clean all data files in the org's data path. Usually <workspace>/.sfdx/orgs/<username>.
     * @param {string} [orgDataPath] A relative path other than "orgs/".
     * @returns {Promise<void>}
     */
    cleanLocalOrgData(orgDataPath?: string, throwWhenRemoveFails?: boolean): Promise<void>;
    retrieveOrgUsersConfig(): Promise<OrgUsersConfig>;
    /**
     * Removes the scratch org config file at $HOME/.sfdx/[name].json, any project level org
     * files, all user auth files for the org, matching default config settings, and any
     * matching aliases.
     * @param {boolean} [throwWhenRemoveFails = false] Determines if the call should throw an error or fail silently.
     * @returns {Promise<void>}
     */
    remove(throwWhenRemoveFails?: boolean): Promise<void>;
    /**
     * Check that this org is a scratch org by asking the dev hub if it knows about it.
     * @param {string} [devHubUsername] The username of the dev hub org.
     * @returns {Promise<Config>}
     * @throws {SfdxError} **`{name: 'NotADevHub'}`** Not a Dev Hub.
     * @throws {SfdxError} **`{name: 'NoResults'}`** No results.
     */
    checkScratchOrg(devHubUsername?: string): Promise<Partial<AuthFields>>;
    /**
     * Returns the Org object or null if this org is not affiliated with a Dev Hub (according to the local config).
     * @returns {Promise<Org>}
     */
    getDevHubOrg(): Promise<Optional<Org>>;
    /**
     * Returns `true` if the org is a Dev Hub.
     * @returns {Boolean}
     */
    isDevHubOrg(): boolean;
    /**
     * Refreshes the auth for this org's instance by calling HTTP GET on the baseUrl of the connection object.
     * @returns {Promise<void>}
     */
    refreshAuth(): Promise<void>;
    /**
     *  Reads and returns the content of all user auth files for this org as an array.
     *  @returns {Promise<AuthInfo[]>}
     */
    readUserAuthFiles(): Promise<AuthInfo[]>;
    /**
     * Adds a username to the user config for this org.
     * @param {AuthInfo | string} auth The AuthInfo for the username to add.
     * @returns {Promise<Org>} For convenience `this` object is returned.
     * @example
     * const org: Org = await Org.create(await Connection.create(await AuthInfo.create('foo@example.com')));
     * const userAuth: AuthInfo = await AuthInfo.create('bar@example.com');
     * await org.addUsername(userAuth);
     */
    addUsername(auth: AuthInfo | string): Promise<Org>;
    /**
     * Removes a username from the user config for this object.
     * @param {AuthInfo | string} auth The AuthInfo containing the username to remove.
     * @returns {Promise<Org>} For convenience `this` object is returned.
     * @throws {SfdxError} **`{name: 'MissingAuthInfo'}`** Auth info is missing.
     */
    removeUsername(auth: AuthInfo | string): Promise<Org>;
    /**
     * Retrieves the highest api version that is supported by the target server instance. If the apiVersion configured for
     * Sfdx is greater than the one returned in this call an api version mismatch occurs. In the case of the CLI that
     * results in a warning.
     * @returns {Promise<string>} The max api version number, i.e `46.0`.
     */
    retrieveMaxApiVersion(): Promise<string>;
    /**
     * Returns the admin username used to create the org.
     * @return {Optional<string>}
     */
    getUsername(): Optional<string>;
    /**
     * Returns the orgId for this org.
     * @return {string}
     */
    getOrgId(): string;
    /**
     * Returns for the config aggregator.
     * @returns {ConfigAggregator}
     */
    getConfigAggregator(): ConfigAggregator;
    /**
     * Returns an org field. Returns undefined if the field is not set or invalid.
     * @returns {AnyJson}
     */
    getField(key: OrgFields): AnyJson;
    /**
     * Returns a map of requested fields.
     * @returns {Dictionary<AnyJson>}
     */
    getFields(keys: OrgFields[]): Dictionary<AnyJson>;
    /**
     * Returns the JSForce connection for the org.
     * @returns {Connection}
     */
    getConnection(): Connection;
    /**
     * Sets the JSForce connection to use for this org.
     * @param {Connection} connection The connection to use.
     * @returns {Org} For convenience `this` object is returned.
     * @throws {SfdxError} **`{name: 'UndefinedConnection'}`** The connection was not defined.
     * @see {@link http://jsforce.github.io/jsforce/doc/Connection.html}
     */
    private setConnection;
    private manageDelete;
}
