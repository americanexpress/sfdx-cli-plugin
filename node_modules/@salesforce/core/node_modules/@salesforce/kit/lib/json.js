"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ts_types_1 = require("@salesforce/ts-types");
const errors_1 = require("./errors");
/**
 * Parse JSON `string` data.
 *
 * @param data Data to parse.
 * @param jsonPath The file path from which the JSON was loaded.
 * @param throwOnEmpty If the data contents are empty.
 * @throws {@link JsonParseError} If the data contents are empty or the data is invalid.
 */
function parseJson(data, jsonPath, throwOnEmpty = true) {
    data = data.trim();
    if (!throwOnEmpty && data.length === 0)
        data = '{}';
    try {
        return JSON.parse(data);
    }
    catch (error) {
        throw errors_1.JsonParseError.create(error, data, jsonPath);
    }
}
exports.parseJson = parseJson;
/**
 * Parse JSON `string` data, expecting the result to be a `JsonMap`.
 *
 * @param data Data to parse.
 * @param jsonPath The file path from which the JSON was loaded.
 * @param throwOnEmpty If the data contents are empty.
 * @returns {JsonMap}
 * @throws {@link JsonParseError} If the data contents are empty or the data is invalid.
 * @throws {@link JsonDataFormatError} If the data contents are not a `JsonMap`.
 */
function parseJsonMap(data, jsonPath, throwOnEmpty) {
    const json = parseJson(data, jsonPath, throwOnEmpty);
    if (json === null || Array.isArray(json) || typeof json !== 'object') {
        throw new errors_1.JsonDataFormatError('Expected parsed JSON data to be an object');
    }
    return json;
}
exports.parseJsonMap = parseJsonMap;
/**
 * Perform a deep clone of an object or array compatible with JSON stringification.
 * Object fields that are not compatible with stringification will be omitted.  Array
 * entries that are not compatible with stringification will be censored as `null`.
 *
 * @param obj A JSON-compatible object or array to clone.
 * @returns {T}
 * @throws {@link JsonStringifyError} If the object contains circular references or causes
 *  other JSON stringification errors.
 */
function cloneJson(obj) {
    try {
        return JSON.parse(JSON.stringify(obj));
    }
    catch (err) {
        throw new errors_1.JsonStringifyError(err);
    }
}
exports.cloneJson = cloneJson;
/**
 * Finds all elements of type `T` with a given name in a `JsonMap`.  Not suitable for use
 * with object graphs containing circular references.  The specification of an appropriate
 * type `T` that will satisfy all matching element values is the responsibility of the caller.
 *
 * @param json The `JsonMap` tree to search for elements of the given name.
 * @param name The name of elements to search for.
 * @returns {T[]} An array of matching elements.
 */
function getJsonValuesByName(json, name) {
    let matches = [];
    if (json.hasOwnProperty(name)) {
        matches.push(json[name]); // Asserting T here assumes the caller knows what they are asking for
    }
    const maybeRecurse = (element) => {
        if (ts_types_1.isJsonMap(element)) {
            matches = matches.concat(getJsonValuesByName(element, name));
        }
    };
    Object.values(json).forEach(value => ts_types_1.isJsonArray(value) ? value.forEach(maybeRecurse) : maybeRecurse(value));
    return matches;
}
exports.getJsonValuesByName = getJsonValuesByName;
//# sourceMappingURL=json.js.map