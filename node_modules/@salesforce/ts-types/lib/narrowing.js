"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module narrowing
 */
const errors_1 = require("./errors");
/**
 * Tests whether an `any` value is a `string`.
 *
 * @param value Any value to test.
 */
function isString(value) {
    return typeof value === 'string';
}
exports.isString = isString;
/**
 * Tests whether an `any` value is a `number`.
 *
 * @param value Any value to test.
 */
function isNumber(value) {
    return typeof value === 'number';
}
exports.isNumber = isNumber;
/**
 * Tests whether an `any` value is a `boolean`.
 *
 * @param value Any value to test.
 */
function isBoolean(value) {
    return typeof value === 'boolean';
}
exports.isBoolean = isBoolean;
/**
 * Tests whether an `any` value is an `object` subtype.
 *
 * @param value Any value to test.
 */
function isObject(value) {
    return value !== null && typeof value === 'object';
}
exports.isObject = isObject;
/**
 * Tests whether or not an `any` value is a plain JS object.
 *
 * @param value Any value to test.
 */
function isPlainObject(value) {
    return Object.prototype.toString.call(value) === '[object Object]';
}
exports.isPlainObject = isPlainObject;
/**
 * Tests whether an `any` value is an `Array`.
 *
 * @param value Any value to test.
 */
function isArray(value) {
    return Array.isArray(value);
}
exports.isArray = isArray;
/**
 * Tests whether an `any` value is a `function`.
 *
 * @param value Any value to test.
 */
function isFunction(value) {
    return typeof value === 'function';
}
exports.isFunction = isFunction;
/**
 * Tests whether or not a `key` string is a key of the given object type `T`.
 *
 * @param key The string to test as a key of the target object.
 * @param obj The target object to check the key in.
 */
function isKeyOf(key, obj) {
    return Object.keys(obj).includes(key);
}
exports.isKeyOf = isKeyOf;
/**
 * Tests whether `any` value is a valid JSON type.
 *
 * @param value The value to test.
 */
function isAnyJson(value) {
    return value === null
        || isString(value)
        || isNumber(value)
        || isBoolean(value)
        || isJsonMap(value)
        || isJsonArray(value);
}
exports.isAnyJson = isAnyJson;
/**
 * Tests whether an `AnyJson` value is an object.
 *
 * @param value An `AnyJson` value to test.
 */
function isJsonMap(value) {
    return isPlainObject(value);
}
exports.isJsonMap = isJsonMap;
/**
 * Tests whether an `AnyJson` value is an array.
 *
 * @param value An `AnyJson` value to test.
 */
function isJsonArray(value) {
    return Array.isArray(value);
}
exports.isJsonArray = isJsonArray;
// underlying function
function asAnyJson(value, defaultValue) {
    return isAnyJson(value) ? value : defaultValue;
}
exports.asAnyJson = asAnyJson;
// underlying function
function asString(value, defaultValue) {
    return isString(value) ? value : defaultValue;
}
exports.asString = asString;
// underlying function
function asNumber(value, defaultValue) {
    return isNumber(value) ? value : defaultValue;
}
exports.asNumber = asNumber;
// underlying function
function asBoolean(value, defaultValue) {
    return isBoolean(value) ? value : defaultValue;
}
exports.asBoolean = asBoolean;
// underlying function
function asJsonMap(value, defaultValue) {
    return isJsonMap(value) ? value : defaultValue;
}
exports.asJsonMap = asJsonMap;
// underlying function
function asJsonArray(value, defaultValue) {
    return isJsonArray(value) ? value : defaultValue;
}
exports.asJsonArray = asJsonArray;
/**
 * Narrows a type `Nullable<T>` to a `T` or raises an error.
 *
 * @param value The value to test.
 * @param message The error message to use if `value` is `undefined` or `null`.
 * @throws {@link UnexpectedValueTypeError} If the value was undefined.
 */
function ensure(value, message) {
    if (value == null) {
        throw new errors_1.UnexpectedValueTypeError(message || 'Value is undefined');
    }
    return value;
}
exports.ensure = ensure;
/**
 * Narrows an `any` value to an `AnyJson` if it is type-compatible, or returns undefined otherwise.
 *
 * @param value An `AnyJson` value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link UnexpectedValueTypeError} If the value was not a JSON value type.
 */
function ensureAnyJson(value, message) {
    if (!isAnyJson(value)) {
        throw new errors_1.UnexpectedValueTypeError(message || 'Value is not a JSON value type');
    }
    return value;
}
exports.ensureAnyJson = ensureAnyJson;
/**
 * Narrows an `AnyJson` value to a `string` if it is type-compatible, or raises an error otherwise.
 *
 * @param value An `AnyJson` value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link UnexpectedValueTypeError} If the value was undefined.
 */
function ensureString(value, message) {
    if (!isString(value)) {
        throw new errors_1.UnexpectedValueTypeError(message || 'Value is not a string');
    }
    return value;
}
exports.ensureString = ensureString;
/**
 * Narrows an `AnyJson` value to a `number` if it is type-compatible, or raises an error otherwise.
 *
 * @param value An `AnyJson` value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link UnexpectedValueTypeError} If the value was undefined.
 */
function ensureNumber(value, message) {
    if (!isNumber(value)) {
        throw new errors_1.UnexpectedValueTypeError(message || 'Value is not a number');
    }
    return value;
}
exports.ensureNumber = ensureNumber;
/**
 * Narrows an `AnyJson` value to a `boolean` if it is type-compatible, or raises an error otherwise.
 *
 * @param value An `AnyJson` value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link UnexpectedValueTypeError} If the value was undefined.
 */
function ensureBoolean(value, message) {
    if (!isBoolean(value)) {
        throw new errors_1.UnexpectedValueTypeError(message || 'Value is not a boolean');
    }
    return value;
}
exports.ensureBoolean = ensureBoolean;
/**
 * Narrows an `AnyJson` value to a `JsonMap` if it is type-compatible, or raises an error otherwise.
 *
 * @param value An `AnyJson` value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link UnexpectedValueTypeError} If the value was undefined.
 */
function ensureJsonMap(value, message) {
    if (!isJsonMap(value)) {
        throw new errors_1.UnexpectedValueTypeError(message || 'Value is not a JsonMap');
    }
    return value;
}
exports.ensureJsonMap = ensureJsonMap;
/**
 * Narrows an `AnyJson` value to a `JsonArray` if it is type-compatible, or raises an error otherwise.
 *
 * @param value An `AnyJson` value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link UnexpectedValueTypeError} If the value was undefined.
 */
function ensureJsonArray(value, message) {
    if (!isJsonArray(value)) {
        throw new errors_1.UnexpectedValueTypeError(message || 'Value is not a JsonArray');
    }
    return value;
}
exports.ensureJsonArray = ensureJsonArray;
// underlying function
function getAsAnyJson(json, path, defaultValue) {
    if (typeof path === 'string') {
        path = path.split('.');
    }
    let index = 0;
    let node = json;
    while (isJsonMap(node) && index < path.length) {
        node = node[path[index++]];
    }
    return ((index && index === path.length) ? node : undefined) || defaultValue;
}
exports.getAsAnyJson = getAsAnyJson;
// underlying function
function getAsString(json, path, defaultValue) {
    if (defaultValue)
        return ensureString(getAsAnyJson(json, path, defaultValue));
    return asString(getAsAnyJson(json, path));
}
exports.getAsString = getAsString;
// underlying function
function getAsNumber(json, path, defaultValue) {
    if (defaultValue)
        return ensureNumber(getAsAnyJson(json, path, defaultValue));
    return asNumber(getAsAnyJson(json, path));
}
exports.getAsNumber = getAsNumber;
// underlying function
function getAsBoolean(json, path, defaultValue) {
    if (defaultValue)
        return ensureBoolean(getAsAnyJson(json, path, defaultValue));
    return asBoolean(getAsAnyJson(json, path));
}
exports.getAsBoolean = getAsBoolean;
// underlying function
function getAsJsonMap(json, path, defaultValue) {
    if (defaultValue)
        return ensureJsonMap(getAsAnyJson(json, path, defaultValue));
    return asJsonMap(getAsAnyJson(json, path));
}
exports.getAsJsonMap = getAsJsonMap;
// underlying function
function getAsJsonArray(json, path, defaultValue) {
    if (defaultValue)
        return ensureJsonArray(getAsAnyJson(json, path, defaultValue));
    return asJsonArray(getAsAnyJson(json, path));
}
exports.getAsJsonArray = getAsJsonArray;
/**
 * Gets an `AnyJson` element of a `JsonMap` given a query path, or raises an error if not found or not type-compatible.
 *
 * @param json The `JsonMap` to query.
 * @param path The query path.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link UnexpectedValueTypeError} If the value was undefined or not type-compatible.
 */
function getEnsureAnyJson(json, path, message) {
    return ensureAnyJson(getAsAnyJson(json, path), message);
}
exports.getEnsureAnyJson = getEnsureAnyJson;
/**
 * Gets a `string` element of a `JsonMap` given a query path, or raises an error if not found or not type-compatible.
 *
 * @param json The `JsonMap` to query.
 * @param path The query path.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link UnexpectedValueTypeError} If the value was undefined or not type-compatible.
 */
function getEnsureString(json, path, message) {
    return ensureString(getAsAnyJson(json, path), message);
}
exports.getEnsureString = getEnsureString;
/**
 * Gets a `number` element of a `JsonMap` given a query path, or raises an error if not found or not type-compatible.
 *
 * @param json The `JsonMap` to query.
 * @param path The query path.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link UnexpectedValueTypeError} If the value was undefined or not type-compatible.
 */
function getEnsureNumber(json, path, message) {
    return ensureNumber(getAsAnyJson(json, path, message));
}
exports.getEnsureNumber = getEnsureNumber;
/**
 * Gets a `boolean` element of a `JsonMap` given a query path, or raises an error if not found or not type-compatible.
 *
 * @param json The `JsonMap` to query.
 * @param path The query path.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link UnexpectedValueTypeError} If the value was undefined or not type-compatible.
 */
function getEnsureBoolean(json, path, message) {
    return ensureBoolean(getAsAnyJson(json, path), message);
}
exports.getEnsureBoolean = getEnsureBoolean;
/**
 * Gets a `JsonMap` element of a `JsonMap` given a query path, or raises an error if not found or not type-compatible.
 *
 * @param json The `JsonMap` to query.
 * @param path The query path.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link UnexpectedValueTypeError} If the value was undefined or not type-compatible.
 */
function getEnsureJsonMap(json, path, message) {
    return ensureJsonMap(getAsAnyJson(json, path), message);
}
exports.getEnsureJsonMap = getEnsureJsonMap;
/**
 * Gets a `JsonArray` element of a `JsonMap` given a query path, or raises an error if not found or not type-compatible.
 *
 * @param json The `JsonMap` to query.
 * @param path The query path.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link UnexpectedValueTypeError} If the value was undefined or not type-compatible.
 */
function getEnsureJsonArray(json, path, message) {
    return ensureJsonArray(getAsAnyJson(json, path), message);
}
exports.getEnsureJsonArray = getEnsureJsonArray;
/**
 * Returns the keys of an object of type `T`.  This is like `Object.keys` except the return type
 * captures the known keys of `T`.
 *
 * Note that it is the responsibility of the caller to use this wisely -- there are cases where
 * the runtime set of keys returned may be broader than the type checked set at compile time,
 * so there's potential for this to be abused in ways that are not inherently type safe.  For
 * example, given base class `Animal`, subclass `Fish`, and `const animal: Animal = new Fish();`
 * then `keysOf(animal)` will not type-check the entire set of keys of the object `animal` since
 * it is actually an instance of type `Fish`.
 *
 * In general, it should be both convenient and type-safe to use this when enumerating the keys
 * of simple data objects with known keys.
 *
 * ```
 * interface Point { x: number; y: number; }
 * const point: Point = { x: 1, y: 2 };
 * for (const key of keysOf(point)) {
 *     console.log(key, point[key]);
 * }
 * // x 1
 * // y 2
 * ```
 *
 * @param obj
 */
function keysOf(obj) {
    return Object.keys(obj);
}
exports.keysOf = keysOf;
/**
 * Returns an array of all entry tuples of type `[string, T]` in a `Dictionary<T>` whose values are neither
 * `null` nor `undefined`.  This can be convenient for enumerating the entries of any `Dictionary` without
 * worrying about performing null checks against possibly `undefined` or `null` values.
 *
 * @param dict The dictionary of interest.
 */
function definiteEntries(dict) {
    return Object.entries(dict).filter((entry) => entry[1] != null);
}
exports.definiteEntries = definiteEntries;
/**
 * Returns an array of all `string` keys in a `Dictionary<T>` whose values are neither `null` nor `undefined`.
 * This can be convenient for enumerating the definitely assigned keys of any `Dictionary`.
 *
 * @param dict The dictionary of interest.
 */
function definiteKeys(dict) {
    return definiteEntries(dict).map(entry => entry[0]);
}
exports.definiteKeys = definiteKeys;
/**
 * Returns an array of all values of type `T` in a `Dictionary<T>` for values that are neither `null` nor `undefined`.
 * This can be convenient for enumerating all non-nullable values of any `Dictionary`.
 *
 * @param dict The dictionary of interest.
 */
function definiteValues(dict) {
    return definiteEntries(dict).map(entry => entry[1]);
}
exports.definiteValues = definiteValues;
//# sourceMappingURL=narrowing.js.map